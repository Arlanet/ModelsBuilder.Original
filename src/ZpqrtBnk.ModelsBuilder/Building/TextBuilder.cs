using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Umbraco.Core.Composing;
using Umbraco.Core.Models;
using Umbraco.Core.Models.PublishedContent;
using ZpqrtBnk.ModelsBuilder.Api;
using ZpqrtBnk.ModelsBuilder.Configuration;

namespace ZpqrtBnk.ModelsBuilder.Building
{
    /// <summary>
    /// Implements a builder that works by writing text.
    /// </summary>
    internal class TextBuilder : Builder
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TextBuilder"/> class with a list of models to generate
        /// and the result of code parsing.
        /// </summary>
        /// <param name="typeModels">The list of models to generate.</param>
        /// <param name="parseResult">The result of code parsing.</param>
        public TextBuilder(IList<TypeModel> typeModels, ParseResult parseResult)
            : base(typeModels, parseResult)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="TextBuilder"/> class with a list of models to generate,
        /// the result of code parsing, and a models namespace.
        /// </summary>
        /// <param name="typeModels">The list of models to generate.</param>
        /// <param name="parseResult">The result of code parsing.</param>
        /// <param name="modelsNamespace">The models namespace.</param>
        public TextBuilder(IList<TypeModel> typeModels, ParseResult parseResult, string modelsNamespace)
            : base(typeModels, parseResult, modelsNamespace)
        { }

        // internal for unit tests only
        internal TextBuilder()
        { }

        private static Config Config => Current.Configs.ModelsBuilder();

        #region Append Helpers

        private int _indent = 0;

        private string Indent => new string('\t', _indent);

        private void IndentEnter() { _indent++; }

        private void IndentExit() { _indent--; }

        private string NewLine => "\n";

        // fixme - use it 
        private void AppendLine(StringBuilder sb, string text)
        {
            for (var i = 0; i < _indent; i++)
                sb.Append('\t');
            sb.Append(text);
            sb.Append(NewLine);
        }

        private void AppendNewLine(StringBuilder sb)
        {
            sb.Append(NewLine);
        }

        public void AppendNewLineBetween(StringBuilder stringBuilder, ref bool first)
        {
            if (first)
                first = false;
            else
                stringBuilder.Append(NewLine);
        }

        // writes an attribute that identifies code generated by a tool
        // (helps reduce warnings, tools such as FxCop use it)
        // see https://github.com/zpqrtbnk/Zbu.ModelsBuilder/issues/107
        // see https://docs.microsoft.com/en-us/dotnet/api/system.codedom.compiler.generatedcodeattribute
        // see https://blogs.msdn.microsoft.com/codeanalysis/2007/04/27/correct-usage-of-the-compilergeneratedattribute-and-the-generatedcodeattribute/
        //
        // note that the blog post above clearly states that "Nor should it be applied at the type level if the type being generated is a partial class."
        // and since our models are partial classes, we have to apply the attribute against the individual members, not the class itself.
        //
        private void AppendGeneratedCodeAttribute(StringBuilder sb, string tabs) // fixme obsolete
        {
            var indent = _indent;
            _indent = tabs.Length;
            AppendLine(sb, $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ZpqrtBnk.ModelsBuilder\", \"{ApiVersion.Current.Version}\")]");
            _indent = indent;
        }

        private void AppendGeneratedCodeAttribute(StringBuilder sb)
        {
            var mbName = ParseResult.MBClassName;
            AppendLine(sb, $"[GeneratedCodeAttribute({mbName}.Name, {mbName}.VersionString)]");
        }

        private void AppendLocalGeneratedCodeAttribute(StringBuilder sb)
        {
            AppendLine(sb, "[GeneratedCodeAttribute(Name, VersionString)]");
        }

        #endregion

        /// <summary>
        /// Outputs a generated model to a string builder.
        /// </summary>
        /// <param name="sb">The string builder.</param>
        /// <param name="typeModel">The model to generate.</param>
        public void Generate(StringBuilder sb, TypeModel typeModel)
        {
            WriteHeader(sb);

            foreach (var t in TypesUsing)
                sb.AppendFormat("using {0};\n", t);

            sb.Append("\n");
            sb.AppendFormat("namespace {0}\n", GetModelsNamespace());
            sb.Append("{\n");

            WriteContentType(sb, typeModel);

            sb.Append("}\n");
        }

        /// <summary>
        /// Outputs generated models to a string builder.
        /// </summary>
        /// <param name="sb">The string builder.</param>
        /// <param name="typeModels">The models to generate.</param>
        public void Generate(StringBuilder sb, IEnumerable<TypeModel> typeModels)
        {
            WriteHeader(sb);

            foreach (var t in TypesUsing)
                sb.AppendFormat("using {0};\n", t);

            // assembly attributes marker
            sb.Append("\n//ASSATTR\n");

            sb.Append("\n");
            sb.AppendFormat("namespace {0}\n", GetModelsNamespace());
            sb.Append("{\n");

            foreach (var typeModel in typeModels)
            {
                WriteContentType(sb, typeModel);
                sb.Append("\n");
            }

            sb.Append("}\n");
        }

        #region Header

        /// <summary>
        /// Outputs an "auto-generated" header to a string builder.
        /// </summary>
        /// <param name="sb">The string builder.</param>
        public static void WriteHeader(StringBuilder sb)
        {
            TextHeaderWriter.WriteHeader(sb);
        }

        #endregion

        #region Meta

        /// <summary>
        /// fixme
        /// </summary>
        /// <param name="sb">The string builder.</param>
        /// <param name="typeModels">The models to generate.</param>
        public void AppendMeta(StringBuilder sb, IEnumerable<TypeModel> typeModels)
        {
            var typeModelsList = typeModels.ToList();
            var mbName = ParseResult.MBClassName;

            WriteHeader(sb);

            //AppendLine(sb, "// ReSharper disable All");
            //AppendNewLine(sb);

            AppendLine(sb, "using System.CodeDom.Compiler;");
            AppendLine(sb, "using Umbraco.Core.Models.PublishedContent;");
            AppendLine(sb, "using ZpqrtBnk.ModelsBuilder.Umbraco;");

            AppendNewLine(sb);
            AppendLine(sb, $"namespace {GetModelsNamespace()}");
            AppendLine(sb, "{");
            IndentEnter();

            AppendLine(sb, "/// <summary>Models Builder</summary>");
            AppendLine(sb, $"public static partial class {mbName}");
            AppendLine(sb, "{");
            IndentEnter();

            AppendLine(sb, "/// <summary>Gets Models Builder's generator name.</summary>");
            AppendLine(sb, "public const string Name = \"ZpqrtBnk.ModelsBuilder\";");
            AppendNewLine(sb);

            AppendLine(sb, "/// <summary>Gets the Models Builder version that was used to generate the files.</summary>");
            AppendLine(sb, $"public const string VersionString = \"{ApiVersion.Current.Version}\";");
            AppendNewLine(sb);

            AppendMetaItemTypes(sb, typeModelsList);
            AppendNewLine(sb);

            AppendMetaContentTypeAliases(sb, typeModelsList);
            AppendNewLine(sb);

            AppendMetaPropertyTypeAliases(sb, typeModelsList);
            AppendNewLine(sb);

            AppendContentTypes(sb, typeModelsList);
            AppendNewLine(sb);

            AppendPropertyTypes(sb, typeModelsList);

            IndentExit();
            AppendLine(sb, "}"); // MB class

            IndentExit();
            AppendLine(sb, "}"); // namespace
        }

        private void AppendMetaItemTypes(StringBuilder sb, IEnumerable<TypeModel> typeModels)
        {
            AppendLine(sb, "/// <summary>Provides the content type published item types.</summary>");
            AppendLocalGeneratedCodeAttribute(sb); // fixme on type or?
            AppendLine(sb, "public static class ItemType");
            AppendLine(sb, "{");
            IndentEnter();

            var firstType = true;
            foreach (var typeModel in typeModels)
            {
                AppendNewLineBetween(sb, ref firstType);
                AppendMetaItemType(sb, typeModel);
            }

            IndentExit();
            AppendLine(sb, "}");
        }

        private void AppendMetaItemType(StringBuilder sb, TypeModel typeModel)
        {
            AppendLine(sb, $"/// <summary>Gets the published item type of the {typeModel.ClrName} content type.</summary>");
            AppendLine(sb, $"public const PublishedItemType {typeModel.ClrName} = PublishedItemType.{typeModel.ItemType.ToPublishedItemType()};");
        }

        private void AppendMetaContentTypeAliases(StringBuilder sb, IEnumerable<TypeModel> typeModels)
        {
            AppendLine(sb, "/// <summary>Defines the content type alias constants.</summary>");
            AppendLocalGeneratedCodeAttribute(sb);
            AppendLine(sb, "public static class ContentAlias");
            AppendLine(sb, "{");
            IndentEnter();

            var firstType = true;
            foreach (var typeModel in typeModels)
            {
                AppendNewLineBetween(sb, ref firstType);
                AppendMetaContentTypeAlias(sb, typeModel);
            }

            IndentExit();
            AppendLine(sb, "}");
        }

        private void AppendMetaContentTypeAlias(StringBuilder sb, TypeModel typeModel)
        {
            AppendLine(sb, $"/// <summary>Gets the alias of the {typeModel.ClrName} content type.</summary>");
            AppendLine(sb, $"public const string {typeModel.ClrName} = \"{typeModel.Alias}\";");
        }

        private void AppendMetaPropertyTypeAliases(StringBuilder sb, IEnumerable<TypeModel> typeModels)
        {
            AppendLine(sb, "/// <summary>Defines the property type alias constants.</summary>");
            AppendLocalGeneratedCodeAttribute(sb);
            AppendLine(sb, "public static class PropertyAlias");
            AppendLine(sb, "{");
            IndentEnter();

            var firstType = true;
            foreach (var typeModel in typeModels)
            {
                AppendNewLineBetween(sb, ref firstType);
                AppendMetaPropertyTypeAliases(sb, typeModel);
            }

            IndentExit();
            AppendLine(sb, "}");
        }

        private void AppendMetaPropertyTypeAliases(StringBuilder sb, TypeModel typeModel)
        {
            AppendLine(sb, $"/// <summary>Defines the property type alias constants for the {typeModel.ClrName} content type.</summary>");
            AppendLine(sb, $"public static class {typeModel.ClrName}");
            AppendLine(sb, "{");
            IndentEnter();

            var firstProperty = true;
            foreach (var propertyModel in typeModel.Properties)
            {
                AppendNewLineBetween(sb, ref firstProperty);
                AppendMetaPropertyTypeAlias(sb, typeModel, propertyModel);
            }

            IndentExit();
            AppendLine(sb, "}");
        }

        private void AppendMetaPropertyTypeAlias(StringBuilder sb, TypeModel typeModel, PropertyModel propertyModel)
        {
            AppendLine(sb, $"/// <summary>Gets the alias of the {typeModel.ClrName}.{propertyModel.ClrName} property type.</summary>");
            AppendLine(sb, $"public const string {propertyModel.ClrName} = \"{propertyModel.Alias}\";");
        }

        private void AppendContentTypes(StringBuilder sb, IEnumerable<TypeModel> typeModels)
        {
            AppendLine(sb, "/// <summary>Provides the content types.</summary>");
            AppendLocalGeneratedCodeAttribute(sb);
            AppendLine(sb, "public static class ContentType");
            AppendLine(sb, "{");
            IndentEnter();

            var firstType = true;
            foreach (var typeModel in typeModels)
            {
                AppendNewLineBetween(sb, ref firstType);
                AppendContentType(sb, typeModel);
            }

            IndentExit();
            AppendLine(sb, "}");
        }

        private void AppendContentType(StringBuilder sb, TypeModel typeModel)
        {
            AppendLine(sb, $"/// <summary>Gets the {typeModel.ClrName} content type.</summary>");
            AppendLine(sb, $"public static readonly IPublishedContentType {typeModel.ClrName} = PublishedModelUtility.GetModelContentType(ItemType.{typeModel.ClrName}, \"{typeModel.Alias}\");");
        }

        private void AppendPropertyTypes(StringBuilder sb, IEnumerable<TypeModel> typeModels)
        {
            AppendLine(sb, "/// <summary>Provides the property types.</summary>");
            AppendLocalGeneratedCodeAttribute(sb);
            AppendLine(sb, "public static class PropertyType");
            AppendLine(sb, "{");
            IndentEnter();

            var firstType = true;
            foreach (var typeModel in typeModels)
            {
                AppendNewLineBetween(sb, ref firstType);
                AppendPropertyTypes(sb, typeModel);
            }

            IndentExit();
            AppendLine(sb, "}");
        }

        private void AppendPropertyTypes(StringBuilder sb, TypeModel typeModel)
        {
            AppendLine(sb, $"/// <summary>Provides the property types for the {typeModel.ClrName} content type.</summary>");
            AppendLine(sb, $"public static class {typeModel.ClrName}");
            AppendLine(sb, "{");
            IndentEnter();

            var firstProperty = true;
            foreach (var propertyModel in typeModel.Properties)
            {
                AppendNewLineBetween(sb, ref firstProperty);
                AppendPropertyType(sb, typeModel, propertyModel);
            }

            IndentExit();
            AppendLine(sb, "}");
        }

        private void AppendPropertyType(StringBuilder sb, TypeModel typeModel, PropertyModel propertyModel)
        {
            AppendLine(sb, $"/// <summary>Gets the {typeModel.ClrName}.{propertyModel.ClrName} property type.</summary>");
            AppendLine(sb, $"public static readonly IPublishedPropertyType {propertyModel.ClrName} = ContentType.{typeModel.ClrName}.GetPropertyType(PropertyAlias.{typeModel.ClrName}.{propertyModel.ClrName});");
        }

        #endregion

        private void WriteContentType(StringBuilder sb, TypeModel type)
        {
            string sep;

            // generate interface for mixins
            if (type.IsMixin)
            {
                // write the interface declaration
                sb.AppendFormat("\t// Mixin Content Type with alias \"{0}\"\n", type.Alias);
                if (!string.IsNullOrWhiteSpace(type.Name))
                    sb.AppendFormat("\t/// <summary>{0}</summary>\n", XmlCommentString(type.Name));
                sb.AppendFormat("\tpublic partial interface I{0}", type.ClrName);
                var implements = type.BaseType == null || type.BaseType.IsContentIgnored
                    ? (type.HasBase ? null : (type.IsElement ? "PublishedElement" : "PublishedContent"))
                    : type.BaseType.ClrName;
                if (implements != null)
                    sb.AppendFormat(" : I{0}", implements);

                // write the mixins
                sep = implements == null ? ":" : ",";
                foreach (var mixinType in type.DeclaringInterfaces.OrderBy(x => x.ClrName))
                {
                    sb.AppendFormat("{0} I{1}", sep, mixinType.ClrName);
                    sep = ",";
                }

                sb.Append("\n\t{\n");

                // write the properties - only the local (non-ignored) ones, we're an interface
                var more = false;
                foreach (var prop in type.Properties.Where(x => !x.IsIgnored).OrderBy(x => x.ClrName))
                {
                    if (more) sb.Append("\n");
                    more = true;
                    WriteInterfaceProperty(sb, prop);
                }

                sb.Append("\t}\n\n");
            }

            // write extension methods for properties
            var extensionProperties = type.Properties.Where(x => !x.IsIgnored && !x.IsExtensionImplemented).ToList();
            if (extensionProperties.Count > 0)
            {
                sb.AppendFormat("\t/// <summary>Provides extension methods for the {0}{1} {2}.</summary>\n",
                    type.IsMixin ? "I" : "", type.ClrName, type.IsMixin ? "interface" : "class");
                sb.AppendFormat("\tpublic static partial class {0}Extensions\n", type.ClrName);
                sb.Append("\t{\n");
                var first = true;
                foreach (var prop in extensionProperties)
                {
                    if (first) first = false;
                    else sb.Append("\n");
                    WritePropertyMethod(sb, type, prop);
                }
                sb.Append("\t}\n\n");
            }

            // write the class declaration
            if (type.IsRenamed)
                sb.AppendFormat("\t// Content Type with alias \"{0}\"\n", type.Alias);
            if (!string.IsNullOrWhiteSpace(type.Name))
                sb.AppendFormat("\t/// <summary>{0}</summary>\n", XmlCommentString(type.Name));
            // cannot do it now. see note in ImplementContentTypeAttribute
            //if (!type.HasImplement)
            //    sb.AppendFormat("\t[ImplementContentType(\"{0}\")]\n", type.Alias);
            sb.AppendFormat("\t[PublishedModel(\"{0}\")]\n", type.Alias);
            sb.AppendFormat("\tpublic partial class {0}", type.ClrName);
            var inherits = type.HasBase
                ? null // has its own base already
                : (type.BaseType == null || type.BaseType.IsContentIgnored
                    ? GetBaseClassName(type)
                    : type.BaseType.ClrName);
            if (inherits != null)
                sb.AppendFormat(" : {0}", inherits);

            sep = inherits == null ? ":" : ",";
            if (type.IsMixin)
            {
                // if it's a mixin it implements its own interface
                sb.AppendFormat("{0} I{1}", sep, type.ClrName);
            }
            else
            {
                // write the mixins, if any, as interfaces
                // only if not a mixin because otherwise the interface already has them already
                foreach (var mixinType in type.DeclaringInterfaces.OrderBy(x => x.ClrName))
                {
                    sb.AppendFormat("{0} I{1}", sep, mixinType.ClrName);
                    sep = ",";
                }
            }

            // begin class body
            sb.Append("\n\t{\n");

            // write the ctor
            if (!type.HasCtor)
                sb.AppendFormat("\t\t// ctor\n\t\tpublic {0}(IPublished{1} content)\n\t\t\t: base(content)\n\t\t{{ }}\n",
                    type.ClrName, type.IsElement ? "Element" : "Content");

            if (!type.HasCtor && ParseResult.GeneratePropertyGetters)
                sb.Append("\n");

            // write the properties
            if (ParseResult.GeneratePropertyGetters)
            {
                sb.Append("\t\t// properties\n");
                WriteContentTypeProperties(sb, type);
            }

            // close the class declaration
            sb.Append("\t}\n");
        }

        private void WriteContentTypeProperties(StringBuilder sb, TypeModel type)
        {
            // write the properties
            foreach (var prop in type.Properties.Where(x => !x.IsIgnored).OrderBy(x => x.ClrName))
                WriteProperty(sb, prop);

            // no need to write the parent properties since we inherit from the parent
            // and the parent defines its own properties. need to write the mixins properties
            // since the mixins are only interfaces and we have to provide an implementation.

            // write the mixins properties
            foreach (var mixinType in type.ImplementingInterfaces.OrderBy(x => x.ClrName))
                foreach (var prop in mixinType.Properties.Where(x => !x.IsIgnored).OrderBy(x => x.ClrName))
                {
                    // exclude directly implemented properties
                    if (type.IgnoredMixinProperties.Contains(prop)) continue;
                    WriteProperty(sb, prop);
                }
        }

        private void WritePropertyMethod(StringBuilder sb, TypeModel type, PropertyModel property)
        {
            if (property.Errors != null) return;

            // Adds xml summary to each property containing
            // property name and property description
            if (!string.IsNullOrWhiteSpace(property.Name) || !string.IsNullOrWhiteSpace(property.Description))
            {
                sb.Append("\t\t///<summary>\n");

                if (!string.IsNullOrWhiteSpace(property.Description))
                    sb.AppendFormat("\t\t/// {0}: {1}\n", XmlCommentString(property.Name), XmlCommentString(property.Description));
                else
                    sb.AppendFormat("\t\t/// {0}\n", XmlCommentString(property.Name));

                sb.Append("\t\t///</summary>\n");
            }

            AppendGeneratedCodeAttribute(sb, "\t\t");

            sb.Append("\t\tpublic static ");
            AppendClrType(sb, property.ClrTypeName);
            sb.Append(" ");
            sb.Append(property.ClrName);
            sb.AppendFormat("(this {0}{1} that", type.IsMixin ? "I" : "", type.ClrName);
            if (property.VariesByCulture())
                sb.Append(", string culture = null");
            if (property.VariesBySegment())
                sb.Append(", string segment = null");
            sb.Append(", Fallback fallback = default, string defaultValue = default)\n\t\t\t=> that.Value");
            if (property.ModelClrType != typeof(object))
            {
                sb.Append("<");
                AppendClrType(sb, property.ClrTypeName);
                sb.Append(">");
            }
            sb.AppendFormat("(\"{0}\"", property.Alias);
            if (property.VariesByCulture())
                sb.Append(", culture: culture");
            if (property.VariesBySegment())
                sb.Append(", segment: segment");
            sb.Append(", fallback: fallback, defaultValue: defaultValue);\n");
        }

        private void WriteProperty(StringBuilder sb, PropertyModel property)
        {
            sb.Append("\n");

            if (property.Errors != null)
            {
                sb.Append("\t\t/*\n");
                sb.Append("\t\t * THIS PROPERTY CANNOT BE IMPLEMENTED, BECAUSE:\n");
                sb.Append("\t\t *\n");
                var first = true;
                foreach (var error in property.Errors)
                {
                    if (first) first = false;
                    else sb.Append("\t\t *\n");
                    foreach (var s in SplitError(error))
                    {
                        sb.Append("\t\t * ");
                        sb.Append(s);
                        sb.Append("\n");
                    }
                }
                sb.Append("\t\t *\n");
                sb.Append("\n");
            }

            // Adds xml summary to each property containing
            // property name and property description
            if (!string.IsNullOrWhiteSpace(property.Name) || !string.IsNullOrWhiteSpace(property.Description))
            {
                sb.Append("\t\t///<summary>\n");

                if (!string.IsNullOrWhiteSpace(property.Description))
                    sb.AppendFormat("\t\t/// {0}: {1}\n", XmlCommentString(property.Name), XmlCommentString(property.Description));
                else
                    sb.AppendFormat("\t\t/// {0}\n", XmlCommentString(property.Name));

                sb.Append("\t\t///</summary>\n");
            }

            AppendGeneratedCodeAttribute(sb, "\t\t");
            sb.AppendFormat("\t\t[ImplementPropertyType(\"{0}\")]\n", property.Alias);

            sb.Append("\t\tpublic ");
            AppendClrType(sb, property.ClrTypeName);
            sb.AppendFormat(" {0} => this.{0}();\n", property.ClrName);

            if (property.Errors != null)
            {
                sb.Append("\n");
                sb.Append("\t\t *\n");
                sb.Append("\t\t */\n");
            }
        }

        private static IEnumerable<string> SplitError(string error)
        {
            var p = 0;
            while (p < error.Length)
            {
                var n = p + 50;
                while (n < error.Length && error[n] != ' ') n++;
                if (n >= error.Length) break;
                yield return error.Substring(p, n - p);
                p = n + 1;
            }
            if (p < error.Length)
                yield return error.Substring(p);
        }

        private void WriteInterfaceProperty(StringBuilder sb, PropertyModel property)
        {
            if (property.Errors != null)
            {
                sb.Append("\t\t/*\n");
                sb.Append("\t\t * THIS PROPERTY CANNOT BE IMPLEMENTED, BECAUSE:\n");
                sb.Append("\t\t *\n");
                var first = true;
                foreach (var error in property.Errors)
                {
                    if (first) first = false;
                    else sb.Append("\t\t *\n");
                    foreach (var s in SplitError(error))
                    {
                        sb.Append("\t\t * ");
                        sb.Append(s);
                        sb.Append("\n");
                    }
                }
                sb.Append("\t\t *\n");
                sb.Append("\n");
            }

            if (!string.IsNullOrWhiteSpace(property.Name))
                sb.AppendFormat("\t\t/// <summary>{0}</summary>\n", XmlCommentString(property.Name));
            AppendGeneratedCodeAttribute(sb, "\t\t");
            sb.Append("\t\t");
            AppendClrType(sb, property.ClrTypeName);
            sb.AppendFormat(" {0} {{ get; }}\n",
                property.ClrName);

            if (property.Errors != null)
            {
                sb.Append("\n");
                sb.Append("\t\t *\n");
                sb.Append("\t\t */\n");
            }
        }

        #region Clr Types

        // internal for tests
        internal void AppendClrType(StringBuilder sb, Type type)
        {
            var s = type.ToString();

            if (type.IsGenericType)
            {
                var p = s.IndexOf('`');
                AppendNonGenericClrType(sb, s.Substring(0, p));
                sb.Append("<");
                var args = type.GetGenericArguments();
                for (var i = 0; i < args.Length; i++)
                {
                    if (i > 0) sb.Append(", ");
                    AppendClrType(sb, args[i]);
                }
                sb.Append(">");
            }
            else
            {
                AppendNonGenericClrType(sb, s);
            }
        }

        // internal for tests
        internal void AppendClrType(StringBuilder sb, string type)
        {
            var p = type.IndexOf('<');
            if (type.Contains('<'))
            {
                AppendNonGenericClrType(sb, type.Substring(0, p));
                sb.Append("<");
                var args = type.Substring(p + 1).TrimEnd('>').Split(','); // fixme will NOT work with nested generic types
                for (var i = 0; i < args.Length; i++)
                {
                    if (i > 0) sb.Append(", ");
                    AppendClrType(sb, args[i]);
                }
                sb.Append(">");
            }
            else
            {
                AppendNonGenericClrType(sb, type);
            }
        }

        private void AppendNonGenericClrType(StringBuilder sb, string s)
        {
            // map model types
            s = Regex.Replace(s, @"\{(.*)\}\[\*\]", m => ModelsMap[m.Groups[1].Value + "[]"]);

            // takes care eg of "System.Int32" vs. "int"
            if (TypesMap.TryGetValue(s, out var typeName))
            {
                sb.Append(typeName);
                return;
            }

            // if full type name matches a using clause, strip
            // so if we want Umbraco.Core.Models.IPublishedContent
            // and using Umbraco.Core.Models, then we just need IPublishedContent
            // also works for the models namespace
            typeName = s;
            string typeUsing = null;
            var p = typeName.LastIndexOf('.');
            if (p > 0)
            {
                var x = typeName.Substring(0, p);
                if (Using.Contains(x) || x == ModelsNamespace)
                {
                    typeName = typeName.Substring(p + 1);
                    typeUsing = x;
                }
            }

            // nested types *after* using
            typeName = typeName.Replace("+", ".");

            // symbol to test is the first part of the name
            // so if type name is Foo.Bar.Nil we want to ensure that Foo is not ambiguous
            p = typeName.IndexOf('.');
            var symbol = p > 0 ? typeName.Substring(0, p) : typeName;

            // what we should find - WITHOUT any generic <T> thing - just the type
            // no 'using' = the exact symbol
            // a 'using' = using.symbol
            var match = typeUsing == null ? symbol : (typeUsing + "." + symbol);

            // if not ambiguous, be happy
            if (!IsAmbiguousSymbol(symbol, match))
            {
                sb.Append(typeName);
                return;
            }

            // symbol is ambiguous
            // if no 'using', must prepend global::
            if (typeUsing == null)
            {
                sb.Append("global::");
                sb.Append(s.Replace("+", "."));
                return;
            }

            // could fullname be non-ambiguous?
            // note: all-or-nothing, not trying to segment the using clause
            typeName = s.Replace("+", ".");
            p = typeName.IndexOf('.');
            symbol = typeName.Substring(0, p);
            match = symbol;

            // still ambiguous, must prepend global::
            if (IsAmbiguousSymbol(symbol, match))
                sb.Append("global::");

            sb.Append(typeName);
        }

        private static readonly IDictionary<string, string> TypesMap = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            { "System.Int16", "short" },
            { "System.Int32", "int" },
            { "System.Int64", "long" },
            { "System.String", "string" },
            { "System.Object", "object" },
            { "System.Boolean", "bool" },
            { "System.Void", "void" },
            { "System.Char", "char" },
            { "System.Byte", "byte" },
            { "System.UInt16", "ushort" },
            { "System.UInt32", "uint" },
            { "System.UInt64", "ulong" },
            { "System.SByte", "sbyte" },
            { "System.Single", "float" },
            { "System.Double", "double" },
            { "System.Decimal", "decimal" }
        };

        #endregion

        private static string XmlCommentString(string s)
        {
            return s.Replace('<', '{').Replace('>', '}').Replace('\r', ' ').Replace('\n', ' ');
        }
    }
}
