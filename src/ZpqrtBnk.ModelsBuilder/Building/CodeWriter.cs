using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using ZpqrtBnk.ModelsBuilder.Api;

namespace ZpqrtBnk.ModelsBuilder.Building
{
    /// <summary>
    /// Provides the default code writer.
    /// </summary>
    public class CodeWriter : CodeWriterBase, ICodeWriter
    {
        public CodeWriter(StringBuilder text, CodeModel model) 
            : base(text)
        {
            CodeModel = model;
        }

        public CodeWriter(CodeModel model)
            : this(new StringBuilder(), model)
        { }

        protected CodeModel CodeModel { get; }

        #region Helpers

        // writes an attribute that identifies code generated by a tool
        // (helps reduce warnings, tools such as FxCop use it)
        // see https://github.com/zpqrtbnk/Zbu.ModelsBuilder/issues/107
        // see https://docs.microsoft.com/en-us/dotnet/api/system.codedom.compiler.generatedcodeattribute
        // see https://blogs.msdn.microsoft.com/codeanalysis/2007/04/27/correct-usage-of-the-compilergeneratedattribute-and-the-generatedcodeattribute/
        //
        // note that the blog post above clearly states that "Nor should it be applied at the type level if the type being generated is a partial class."
        // and since our models are partial classes, we have to apply the attribute against the individual members, not the class itself.
        //
        public virtual void WriteGeneratedCodeAttribute()
        {
            var infos = CodeModel.ModelInfosClassName;
            WriteIndentLine($"[GeneratedCodeAttribute({infos}.Name, {infos}.VersionString)]");
        }

        public virtual void WriteLocalGeneratedCodeAttribute()
        {
            WriteIndentLine("[GeneratedCodeAttribute(Name, VersionString)]");
        }

        public virtual void WritePropertyTypeAliasConstant(PropertyModel model)
        {
            Write(CodeModel.ModelInfosClassName);
            Write(".ContentTypes.");
            Write(model.ContentType.ClrName);
            Write(".Properties.");
            Write(model.ClrName);
            Write(".Alias");
        }

        public virtual void WriteContentTypeAliasConstant(ContentTypeModel model)
        {
            Write(CodeModel.ModelInfosClassName);
            Write(".ContentTypes.");
            Write(model.ClrName);
            Write(".Alias");
        }

        protected static string XmlCommentString(string s)
        {
            return s.Replace('<', '{').Replace('>', '}').Replace('\r', ' ').Replace('\n', ' ');
        }

        #endregion

        #region Write Misc

        public virtual void WriteHeader()
        {
            TextHeaderWriter.WriteHeader(Text);
        }

        #endregion

        #region Write Complete Files

        private void WriteUsing(string ns)
        {
            if (!CodeModel.Using.Contains(ns))
                WriteIndentLine($"using {ns};");
        }

        public virtual void WriteUsing()
        {
            foreach (var t in CodeModel.Using)
                WriteIndentLine($"using {t};");
        }

        /// <summary>
        /// Write a single content type model in a file.
        /// </summary>
        /// <param name="model"></param>
        public virtual void WriteModelFile(ContentTypeModel model)
        {
            WriteHeader();
            WriteLine();

            WriteUsing();
            WriteUsing("System.CodeDom.Compiler");
            WriteLine();

            WriteBlockStart($"namespace {CodeModel.ModelsNamespace}");
            WriteContentTypeModel(model);
            WriteBlockEnd();
        }

        /// <summary>
        /// Writes models in a single file.
        /// </summary>
        public virtual void WriteSingleFile(CodeModel model)
        {
            WriteHeader();
            WriteLine();

            WriteUsing();
            WriteUsing("System");
            WriteUsing("System.Linq");
            WriteUsing("System");
            WriteUsing("System.Linq");
            WriteUsing("System.Collections.Generic");
            WriteUsing("System.CodeDom.Compiler");
            WriteUsing("Umbraco.Core.Models.PublishedContent");
            WriteUsing("ZpqrtBnk.ModelsBuilder");
            WriteUsing("ZpqrtBnk.ModelsBuilder.Umbraco");
            WriteLine();

            // assembly attributes marker
            WriteIndentLine("//ASSATTR");
            WriteLine();

            WriteBlockStart($"namespace {CodeModel.ModelsNamespace}");
            WriteContentTypeModels(model.ContentTypeModels);
            WriteBlockEnd();

            WriteLine();

            WriteBlockStart($"namespace {CodeModel.ModelInfosClassNamespace}");
            WriteModelInfosClass(model);
            WriteBlockEnd();
        }

        public virtual void WriteModelInfosFile(CodeModel model)
        {
            WriteHeader();
            WriteLine();

            WriteUsing();
            WriteUsing("System");
            WriteUsing("System.Linq");
            WriteUsing("System.Collections.Generic");
            WriteUsing("System.CodeDom.Compiler");
            WriteUsing("Umbraco.Core.Models.PublishedContent");
            WriteUsing("ZpqrtBnk.ModelsBuilder");
            WriteUsing("ZpqrtBnk.ModelsBuilder.Umbraco");
            WriteLine();

            WriteBlockStart($"namespace {CodeModel.ModelInfosClassNamespace}");
            WriteModelInfosClass(model);
            WriteBlockEnd();
        }

        #endregion

        #region Write ContentType Models

        public virtual void WriteContentTypeModels(IEnumerable<ContentTypeModel> models)
        {
            var first = true;
            foreach (var typeModel in models)
            {
                WriteLineBetween(ref first);
                WriteContentTypeModel(typeModel);
            }
        }

        /// <summary>
        /// Appends a complete content type model.
        /// </summary>
        public virtual void WriteContentTypeModel(ContentTypeModel model)
        {
            if (model.IsMixin)
            {
                WriteInterfaceDeclaration(model);
                WriteLine();
            }

            WriteExtensionsClass(model);
            WriteLine();
            WriteClassDeclaration(model);
        }

        /// <summary>
        /// Appends the interface declaration.
        /// </summary>
        /// <remarks>Appends the properties with <see cref="WriteInterfaceProperties"/>.</remarks>
        protected virtual void WriteInterfaceDeclaration(ContentTypeModel model)
        {
            // write the interface declaration
            WriteIndentLine($"// Mixin Content Type with alias \"{model.Alias}\"");
            if (!string.IsNullOrWhiteSpace(model.Name))
                WriteIndentLine($"/// <summary>{XmlCommentString(model.Name)}</summary>");
            WriteIndent($"public partial interface I{model.ClrName}");

            var implements = model.BaseType == null || model.BaseType.IsContentIgnored
                ? (model.HasBase ? null : (model.IsElement ? "PublishedElement" : "PublishedContent"))
                : model.BaseType.ClrName;

            if (implements != null)
                Write($" : I{implements}");

            // write the mixins
            var sep = implements == null ? ":" : ",";
            foreach (var mixinType in model.DeclaringInterfaces.OrderBy(x => x.ClrName))
            {
                Write($"{sep} I{mixinType.ClrName}");
                sep = ",";
            }

            WriteLine();
            WriteBlockStart();

            if (CodeModel.GeneratePropertyGetters)
                WriteInterfaceProperties(model);

            WriteBlockEnd();
        }

        /// <summary>
        /// Appends the interface properties.
        /// </summary>
        /// <remarks>Appends each property with <see cref="WriteInterfaceProperty"/>.</remarks>
        protected virtual void WriteInterfaceProperties(ContentTypeModel model)
        {
            // write the properties - only the local (non-ignored) ones, we're an interface
            var firstProperty = true;
            foreach (var propertyModel in model.Properties.Where(x => !x.IsIgnored).OrderBy(x => x.ClrName))
            {
                WriteLineBetween(ref firstProperty);
                WriteInterfaceProperty(propertyModel);
            }
        }

        /// <summary>
        /// Appends an interface property.
        /// </summary>
        protected virtual void WriteInterfaceProperty(PropertyModel model)
        {
            if (model.Errors != null)
                WritePropertyErrorsStart(model.Errors);

            if (!string.IsNullOrWhiteSpace(model.Name))
                WriteIndentLine($"/// <summary>{XmlCommentString(model.Name)}</summary>");

            WriteGeneratedCodeAttribute();
            WriteIndent();
            WriteClrType(model.ClrTypeName);
            WriteLine($" {model.ClrName} {{ get; }}");

            if (model.Errors != null)
                WritePropertyErrorsEnd();
        }

        /// <summary>
        /// Appends the class declaration.
        /// </summary>
        /// <remarks>Appends the constructor with <see cref="WriteClassConstructor"/>, and the properties
        /// with <see cref="WriteClassProperties"/>.</remarks>
        protected virtual void WriteClassDeclaration(ContentTypeModel model)
        {
            // append comments
            if (model.IsRenamed)
                WriteIndentLine($"// Content Type with alias \"{model.Alias}\"");

            if (!string.IsNullOrWhiteSpace(model.Name))
                WriteIndentLine($"/// <summary>{XmlCommentString(model.Name)}</summary>");
            else
                WriteIndentLine($"/// <summary>Represents a \"{model.Alias}\" content item.</summary>");

            // cannot do it now. see note in ImplementContentTypeAttribute
            //if (!type.HasImplement)
            //    sb.AppendFormat("\t[ImplementContentType(\"{0}\")]\n", type.Alias);

            // append the 'class' line
            WriteIndent("[PublishedModel(");
            WriteContentTypeAliasConstant(model);
            WriteLine(")]");

            WriteIndent($"public partial class {model.ClrName}");

            var inherits = model.HasBase
                ? null // has its own base already
                : (model.BaseType == null || model.BaseType.IsContentIgnored
                    ? model.BaseClassName
                    : model.BaseType.ClrName);

            if (inherits != null)
                Write($" : {inherits}");

            var sep = inherits == null ? ":" : ",";
            if (model.IsMixin)
            {
                // if it's a mixin it implements its own interface
                Write($"{sep} I{model.ClrName}");
            }
            else
            {
                // write the mixins, if any, as interfaces
                // only if not a mixin because otherwise the interface already has them already
                foreach (var mixinType in model.DeclaringInterfaces.OrderBy(x => x.ClrName))
                {
                    Write($"{sep} I{mixinType.ClrName}");
                    sep = ",";
                }
            }

            WriteLine();

            // begin class body
            WriteBlockStart();

            // write the ctor
            if (!model.HasCtor)
                WriteClassConstructor(model);

            if (!model.HasCtor && CodeModel.GeneratePropertyGetters)
                WriteLine();

            // write the properties
            if (CodeModel.GeneratePropertyGetters)
                WriteClassProperties(model);

            // close the class declaration
            WriteBlockEnd();
        }

        /// <summary>
        /// Appends the class constructor.
        /// </summary>
        protected virtual void WriteClassConstructor(ContentTypeModel model)
        {
            WriteIndentLine($"public {model.ClrName}(IPublished{(model.IsElement ? "Element" : "Content")} content)");
            Indent();
            WriteIndentLine(": base(content)");
            Outdent();
            WriteIndentLine("{ }");
        }

        /// <summary>
        /// Appends the class properties.
        /// </summary>
        /// <remarks>Appends each property with <see cref="WriteClassProperty"/>.</remarks>
        protected virtual void WriteClassProperties(ContentTypeModel model)
        {
            // write the properties
            var first = true;
            foreach (var prop in model.Properties.Where(x => !x.IsIgnored).OrderBy(x => x.ClrName))
            {
                WriteLineBetween(ref first);
                WriteClassProperty(prop);
            }

            // no need to write the parent properties since we inherit from the parent
            // and the parent defines its own properties. need to write the mixins properties
            // since the mixins are only interfaces and we have to provide an implementation.

            // write the mixins properties
            foreach (var mixinType in model.ImplementingInterfaces.OrderBy(x => x.ClrName))
                foreach (var prop in mixinType.Properties.Where(x => !x.IsIgnored).OrderBy(x => x.ClrName))
                {
                    // exclude directly implemented properties
                    if (model.IgnoredMixinProperties.Contains(prop)) continue;
                    WriteLineBetween(ref first);
                    WriteClassProperty(prop);
                }
        }

        /// <summary>
        /// Appends a class property.
        /// </summary>
        protected virtual void WriteClassProperty(PropertyModel model)
        {
            if (model.Errors != null)
                WritePropertyErrorsStart(model.Errors);

            // Adds xml summary to each property containing
            // property name and property description
            if (!string.IsNullOrWhiteSpace(model.Name) || !string.IsNullOrWhiteSpace(model.Description))
            {
                var summary = XmlCommentString(model.Name);
                if (!string.IsNullOrWhiteSpace(model.Description))
                    summary += ": " + XmlCommentString(model.Description);

                WriteIndentLine($"/// <summary>{summary}</summary>");
            }
            else
            {
                WriteIndentLine($"/// <summary>Gets the value of the \"{model.Alias}\" property.</summary>");
            }

            WriteGeneratedCodeAttribute();
            WriteIndent("[ImplementPropertyType(");
            WritePropertyTypeAliasConstant(model);
            WriteLine(")]");
            WriteIndent("public ");
            WriteClrType(model.ClrTypeName);
            WriteLine($" {model.ClrName} => this.{model.ClrName}();");

            if (model.Errors != null)
                WritePropertyErrorsEnd();
        }

        /// <summary>
        /// Appends the extension methods.
        /// </summary>
        /// <remarks>Appends each property's methods with <see cref="WritePropertyExtensionMethods"/>.</remarks>
        protected virtual void WriteExtensionsClass(ContentTypeModel model)
        {
            // write extension methods for properties
            var extensionProperties = model.Properties.Where(x => !x.IsIgnored && !x.IsExtensionImplemented).ToList();
            if (extensionProperties.Count == 0) return;

            WriteIndentLine($"/// <summary>Provides extension methods for the {(model.IsMixin ? "I" : "")}{model.ClrName} {(model.IsMixin ? "interface" : "class")}.</summary>");
            WriteIndentLine($"public static partial class {model.ClrName}Extensions");

            WriteBlockStart();

            var firstProperty = true;
            foreach (var propertyModel in extensionProperties)
            {
                WriteLineBetween(ref firstProperty);
                WritePropertyExtensionMethods(propertyModel);
            }

            WriteBlockEnd();
        }

        /// <summary>
        /// Appends the extension methods for a property.
        /// </summary>
        protected virtual void WritePropertyExtensionMethods(PropertyModel model)
        {
            // append the extension method that mimics .Value(...)
            WriteStandardExtensionMethod(model);

            if (CodeModel.GenerateFallbackFuncExtensionMethods)
            {
                WriteLine();
                WriteFallbackFuncExtensionMethod(model);
            }
        }

        /// <summary>
        /// Appends the standard extension method.
        /// </summary>
        protected virtual void WriteStandardExtensionMethod(PropertyModel model)
        {
            if (model.Errors != null) return;

            // Adds xml summary to each property containing
            // property name and property description
            if (!string.IsNullOrWhiteSpace(model.Name) || !string.IsNullOrWhiteSpace(model.Description))
            {
                var summary = XmlCommentString(model.Name);
                if (!string.IsNullOrWhiteSpace(model.Description))
                    summary += ": " + XmlCommentString(model.Description);

                WriteIndentLine($"/// <summary>{summary}</summary>");
            }
            else
            {
                WriteIndentLine($"/// <summary>Gets the value of the \"{model.Alias}\" property.</summary>");
            }

            WriteGeneratedCodeAttribute();

            WriteIndent("public static ");
            WriteClrType(model.ClrTypeName);
            Write(" ");
            Write(model.ClrName);
            Write($"(this {(model.ContentType.IsMixin ? "I" : "")}{model.ContentType.ClrName} that");
            if (model.VariesByCulture())
                Write(", string culture = null");
            if (model.VariesBySegment())
                Write(", string segment = null");
            Write(", Fallback fallback = default, ");
            WriteClrType(model.ClrTypeName);
            WriteLine(" defaultValue = default)");
            
            Indent();

            WriteIndent("=> that.Value");
            if (model.ModelClrType != typeof(object))
            {
                Write("<");
                WriteClrType(model.ClrTypeName);
                Write(">");
            }
            Write("(");
            WritePropertyTypeAliasConstant(model);
            if (model.VariesByCulture())
                Write(", culture: culture");
            if (model.VariesBySegment())
                Write(", segment: segment");
            WriteLine(", fallback: fallback, defaultValue: defaultValue);");

            Outdent();
        }

        /// <summary>
        /// Appends the fallback-function extension method.
        /// </summary>
        protected virtual void WriteFallbackFuncExtensionMethod(PropertyModel model)
        {
            if (model.Errors != null) return;

            // Adds xml summary to each property containing
            // property name and property description
            if (!string.IsNullOrWhiteSpace(model.Name) || !string.IsNullOrWhiteSpace(model.Description))
            {
                var summary = XmlCommentString(model.Name);
                if (!string.IsNullOrWhiteSpace(model.Description))
                    summary += ": " + XmlCommentString(model.Description);

                WriteIndentLine($"/// <summary>{summary}</summary>");
            }
            else
            {
                WriteIndentLine($"/// <summary>Gets the value of the \"{model.Alias}\" property.</summary>");
            }

            WriteGeneratedCodeAttribute();

            WriteIndent("public static ");
            WriteClrType(model.ClrTypeName);
            Write(" ");
            Write(model.ClrName);
            Write($"(this {(model.ContentType.IsMixin ? "I" : "")}{model.ContentType.ClrName} that");
            if (model.VariesByCulture())
                Write(", string culture = null");
            if (model.VariesBySegment())
                Write(", string segment = null");
            Write(", Func<");
            Write(model.ContentType.ClrName);
            Write(", ");
            //if (propertyModel.VariesByCulture())
            //    sb.Append("string, ");
            //if (propertyModel.VariesBySegment())
            //    sb.Append("string, ");
            WriteClrType(model.ClrTypeName);
            WriteLine("> fallback = default)");

            Indent();

            WriteIndent("=> that.Value");
            Write("<");
            Write(model.ContentType.ClrName);
            Write(", ");
            WriteClrType(model.ClrTypeName); // always use the <,> overload to avoid conflicts
            Write(">(");
            WritePropertyTypeAliasConstant(model);
            if (model.VariesByCulture())
                Write(", culture: culture");
            if (model.VariesBySegment())
                Write(", segment: segment");
            WriteLine(", fallback: fallback);");

            Outdent();
        }

        protected virtual void WritePropertyErrorsStart(IEnumerable<string> errors)
        {
            WriteIndentLine("/*");
            WriteIndentLine(" * THIS PROPERTY CANNOT BE IMPLEMENTED, BECAUSE:");
            WriteIndentLine(" *");

            static IEnumerable<string> SplitError(string error)
            {
                var p = 0;
                while (p < error.Length)
                {
                    var n = p + 50;
                    while (n < error.Length && error[n] != ' ') n++;
                    if (n >= error.Length) break;
                    yield return error.Substring(p, n - p);
                    p = n + 1;
                }
                if (p < error.Length)
                    yield return error.Substring(p);
            }

            var first = true;
            foreach (var error in errors)
            {
                if (first) first = false;
                else WriteIndentLine(" *");
                foreach (var s in SplitError(error))
                {
                    WriteIndentLine(" *" + s);
                }
            }

            WriteIndentLine(" *");
            WriteIndentLine(" *");
            WriteIndentLine(" */");
        }

        protected virtual void WritePropertyErrorsEnd()
        {
            WriteLine();
        }

        #endregion

        #region Write Infos

        protected virtual void WriteModelInfosClass(CodeModel models)
        {
            WriteIndentLine("/// <summary>Provides information about models.</summary>");
            WriteBlockStart($"public static partial class {CodeModel.ModelInfosClassName}");
            WriteModelInfosClassBody(models);
            WriteBlockEnd();
        }

        protected virtual void WriteModelInfosClassBody(CodeModel models)
        {
            WriteIndentLine("/// <summary>Gets ModelsBuilder's generator name.</summary>");
            WriteIndentLine($"public const string Name = \"{CodeModel.GeneratorName}\";");
            WriteLine();

            WriteIndentLine("/// <summary>Gets the ModelsBuilder version that was used to generate the files.</summary>");
            WriteIndentLine($"public const string VersionString = \"{ApiVersion.Current.Version}\";");
            WriteLine();

            WriteContentTypesInfos(models.ContentTypeModels);
        }

        protected virtual void WriteContentTypesInfos(IEnumerable<ContentTypeModel> models)
        {
            WriteContentTypesInfosClass(models);
            WriteLine();

            WriteIndentLine("/// <summary>Gets the content type model infos.</summary>");
            WriteLocalGeneratedCodeAttribute();
            WriteIndentLine("public static IReadOnlyCollection<ContentTypeModelInfo> ContentTypeInfos => _contentTypeInfos;");
            WriteLine();

            WriteIndentLine("/// <summary>Gets the model infos for a content type.</summary>");
            WriteLocalGeneratedCodeAttribute();
            WriteIndentLine("public static ContentTypeModelInfo GetContentTypeInfos(string alias) => _contentTypeInfos.FirstOrDefault(x => x.Alias == alias);");
            WriteLine();

            WriteIndentLine("/// <summary>Gets the model infos for a content type.</summary>");
            WriteLocalGeneratedCodeAttribute();
            WriteIndentLine("public static ContentTypeModelInfo GetContentTypeInfos<TModel>() => _contentTypeInfos.FirstOrDefault(x => x.ClrType == typeof(TModel));");
            WriteLine();

            WriteIndentLine("/// <summary>Gets the model infos for a content type.</summary>");
            WriteLocalGeneratedCodeAttribute();
            WriteIndentLine("public static ContentTypeModelInfo GetContentTypeInfos(Type typeofModel) => _contentTypeInfos.FirstOrDefault(x => x.ClrType == typeofModel);");
            WriteLine();

            WriteContentTypesInfosCollection(models);
        }

        protected virtual void WriteContentTypesInfosClass(IEnumerable<ContentTypeModel> models)
        {
            WriteIndentLine("/// <summary>Provides information about content type models.</summary>");
            WriteBlockStart("public static class ContentTypes");
            WriteContentTypesInfosClassBody(models);
            WriteBlockEnd();
        }

        protected virtual void WriteContentTypesInfosClassBody(IEnumerable<ContentTypeModel> models)
        {
            var first = true;
            foreach (var model in models)
            {
                WriteLineBetween(ref first);
                WriteContentTypeInfosClass(model);
            }
        }

        protected virtual void WriteContentTypesInfosCollection(IEnumerable<ContentTypeModel> models)
        {
            WriteLocalGeneratedCodeAttribute();
            WriteBlockStart("private static readonly ContentTypeModelInfo[] _contentTypeInfos = ");

            var firstType = true;
            foreach (var model in models)
            {
                WriteBetween(ref firstType, $",{NewLine}");

                WriteIndent($"new ContentTypeModelInfo(\"{model.Alias}\", \"{model.ClrName}\", typeof(");
                WriteClrType(CodeModel.ModelsNamespace + "." + model.ClrName);
                Write(")");
                if (model.Properties.Count > 0)
                {
                    WriteLine(",");
                    Indent();
                    var firstProperty = true;
                    foreach (var propertyModel in model.Properties)
                    {
                        WriteBetween(ref firstProperty, $",{NewLine}");
                        WriteIndent($"new PropertyTypeModelInfo(\"{propertyModel.Alias}\", \"{propertyModel.ClrName}\", typeof(");
                        WriteClrType(propertyModel.ClrTypeName);
                        Write("))");
                    }
                    Outdent();
                }

                Write(")");
            }

            WriteLine();

            Outdent();
            WriteIndentLine("};"); // beware of the ';'
        }

        protected virtual void WriteContentTypeInfosClass(ContentTypeModel model)
        {
            WriteIndentLine($"/// <summary>Provides information about the {model.ClrName} content type.</summary>");
            WriteBlockStart($"public static class {model.ClrName}");
            WriteContentTypeInfosClassBody(model);
            WriteBlockEnd();
        }

        protected virtual void WriteContentTypeInfosClassBody(ContentTypeModel model)
        {
            WriteIndentLine($"public const PublishedItemType ItemType = PublishedItemType.{model.ItemType.ToPublishedItemType()};");
            WriteLine();

            WriteIndentLine($"public const string Alias = \"{model.Alias}\";");
            WriteLine();

            WriteIndentLine("public static IPublishedContentType GetContentType() => PublishedModelUtility.GetModelContentType(ItemType, Alias);");
            WriteLine();

            WritePropertyTypesInfosClass(model);
        }

        protected virtual void WritePropertyTypesInfosClass(ContentTypeModel model)
        {
            WriteIndentLine($"/// <summary>Provides information about the properties of the {model.ClrName} content type.</summary>");
            WriteBlockStart("public static class Properties");
            WritePropertyTypesInfosClassBody(model);
            WriteBlockEnd();
        }

        protected virtual void WritePropertyTypesInfosClassBody(ContentTypeModel model)
        {
            var first = true;
            foreach (var propertyModel in model.Properties) // FIXME exclude some?
            {
                WriteLineBetween(ref first);
                WritePropertyTypeInfosClass(propertyModel);
            }
        }

        protected virtual void WritePropertyTypeInfosClass(PropertyModel model)
        {
            WriteBlockStart($"public static class {model.ClrName}");
            WritePropertyTypeInfosClassBody(model);
            WriteBlockEnd();
        }

        protected virtual void WritePropertyTypeInfosClassBody(PropertyModel model)
        {
            WriteIndentLine($"public const string Alias = \"{model.Alias}\";");
            WriteLine();
            WriteIndentLine("public static IPublishedPropertyType GetPropertyType() => GetContentType().GetPropertyType(Alias);");
        }

        #endregion

        #region Write CLR Types

        // internal for tests
        protected internal void WriteClrType(Type type)
        {
            var s = type.ToString();

            if (type.IsGenericType)
            {
                var p = s.IndexOf('`');
                WriteNonGenericClrType(s.Substring(0, p));
                Write("<");
                var args = type.GetGenericArguments();
                for (var i = 0; i < args.Length; i++)
                {
                    if (i > 0) Write(", ");
                    WriteClrType(args[i]);
                }
                Write(">");
            }
            else
            {
                WriteNonGenericClrType(s);
            }
        }

        // internal for tests
        protected internal void WriteClrType(string type)
        {
            var p = type.IndexOf('<');
            if (type.Contains('<'))
            {
                WriteNonGenericClrType(type.Substring(0, p));
                Write("<");
                var args = type.Substring(p + 1).TrimEnd('>').Split(','); // fixme will NOT work with nested generic types
                for (var i = 0; i < args.Length; i++)
                {
                    if (i > 0) Write(", ");
                    WriteClrType(args[i]);
                }
                Write(">");
            }
            else
            {
                WriteNonGenericClrType(type);
            }
        }

        private void WriteNonGenericClrType(string s)
        {
            // map model types
            s = Regex.Replace(s, @"\{(.*)\}\[\*\]", m => CodeModel.ModelsMap[m.Groups[1].Value + "[]"]);

            // takes care eg of "System.Int32" vs. "int"
            if (TypesMap.TryGetValue(s, out var typeName))
            {
                Write(typeName);
                return;
            }

            // if full type name matches a using clause, strip
            // so if we want Umbraco.Core.Models.IPublishedContent
            // and using Umbraco.Core.Models, then we just need IPublishedContent
            // also works for the models namespace
            typeName = s;
            string typeUsing = null;
            var p = typeName.LastIndexOf('.');
            if (p > 0)
            {
                var x = typeName.Substring(0, p);
                if (CodeModel.Using.Contains(x) || x == CodeModel.ModelsNamespace)
                {
                    typeName = typeName.Substring(p + 1);
                    typeUsing = x;
                }
            }

            // nested types *after* using
            typeName = typeName.Replace("+", ".");

            // symbol to test is the first part of the name
            // so if type name is Foo.Bar.Nil we want to ensure that Foo is not ambiguous
            p = typeName.IndexOf('.');
            var symbol = p > 0 ? typeName.Substring(0, p) : typeName;

            // what we should find - WITHOUT any generic <T> thing - just the type
            // no 'using' = the exact symbol
            // a 'using' = using.symbol
            var match = typeUsing == null ? symbol : (typeUsing + "." + symbol);

            // if not ambiguous, be happy
            if (!CodeModel.IsAmbiguousSymbol(symbol, match))
            {
                Write(typeName);
                return;
            }

            // symbol is ambiguous
            // if no 'using', must prepend global::
            if (typeUsing == null)
            {
                Write("global::");
                Write(s.Replace("+", "."));
                return;
            }

            // could fullname be non-ambiguous?
            // note: all-or-nothing, not trying to segment the using clause
            typeName = s.Replace("+", ".");
            p = typeName.IndexOf('.');
            symbol = typeName.Substring(0, p);
            match = symbol;

            // still ambiguous, must prepend global::
            if (CodeModel.IsAmbiguousSymbol(symbol, match))
                Write("global::");

            Write(typeName);
        }

        private static readonly IDictionary<string, string> TypesMap = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            { "System.Int16", "short" },
            { "System.Int32", "int" },
            { "System.Int64", "long" },
            { "System.String", "string" },
            { "System.Object", "object" },
            { "System.Boolean", "bool" },
            { "System.Void", "void" },
            { "System.Char", "char" },
            { "System.Byte", "byte" },
            { "System.UInt16", "ushort" },
            { "System.UInt32", "uint" },
            { "System.UInt64", "ulong" },
            { "System.SByte", "sbyte" },
            { "System.Single", "float" },
            { "System.Double", "double" },
            { "System.Decimal", "decimal" }
        };

        #endregion
    }
}