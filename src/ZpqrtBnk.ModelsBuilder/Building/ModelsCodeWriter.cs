using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Our.ModelsBuilder.Building
{
    /// <summary>
    /// Implements a models code writer.
    /// </summary>
    public abstract class ModelsCodeWriter : CodeWriterBase
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ModelsCodeWriter"/> class.
        /// </summary>
        protected ModelsCodeWriter(CodeModel model, StringBuilder text = null)
            : base(text)
        {
            CodeModel = model;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ModelsCodeWriter"/> class.
        /// </summary>
        protected ModelsCodeWriter(ModelsCodeWriter origin)
            : base(origin)
        {
            CodeModel = origin.CodeModel;
        }

        /// <summary>
        /// Gets the code model.
        /// </summary>
        protected CodeModel CodeModel { get; }

        #region Write misc. code

        // writes an attribute that identifies code generated by a tool
        // (helps reduce warnings, tools such as FxCop use it)
        // see https://github.com/zpqrtbnk/Zbu.ModelsBuilder/issues/107
        // see https://docs.microsoft.com/en-us/dotnet/api/system.codedom.compiler.generatedcodeattribute
        // see https://blogs.msdn.microsoft.com/codeanalysis/2007/04/27/correct-usage-of-the-compilergeneratedattribute-and-the-generatedcodeattribute/
        //
        // note that the blog post above clearly states that "Nor should it be applied at the type level if the type being generated is a partial class."
        // and since our models are partial classes, we have to apply the attribute against the individual members, not the class itself.

        /// <summary>
        /// Writes the <see cref="GeneratedCodeAttribute"/>.
        /// </summary>
        public virtual void WriteGeneratedCodeAttribute()
        {
            var infos = CodeModel.ModelInfosClassName;
            WriteIndentLine($"[GeneratedCodeAttribute({infos}.Name, {infos}.VersionString)]");
        }

        /// <summary>
        /// Writes the <see cref="GeneratedCodeAttribute"/>.
        /// </summary>
        public virtual void WriteLocalGeneratedCodeAttribute()
        {
            WriteIndentLine("[GeneratedCodeAttribute(Name, VersionString)]");
        }

        /// <summary>
        /// Writes the file header.
        /// </summary>
        public virtual void WriteFileHeader()
        {
            TextHeaderWriter.WriteHeader(Text);
        }

        /// <summary>
        /// Converts a string to an Xml comment string.
        /// </summary>
        protected static string XmlCommentString(string s)
        {
            return s.Replace('<', '{').Replace('>', '}').Replace('\r', ' ').Replace('\n', ' ');
        }

        #endregion

        #region Write CLR Types

        // internals for tests

        /// <summary>
        /// Writes a Clr type.
        /// </summary>
        protected internal void WriteClrType(Type type)
        {
            var s = type.FullName;
            if (s == null)
                throw new Exception("Panic: null fullname.");

            // the full name of a ModelTypeArrayType is {alias}[*]
            // the full name of a ModelType is {alias}

            if (type.IsGenericType)
            {
                var p = s.IndexOf('`');
                WriteNonGenericClrType(s.Substring(0, p));
                Write("<");
                var args = type.GetGenericArguments();
                for (var i = 0; i < args.Length; i++)
                {
                    if (i > 0) Write(", ");
                    WriteClrType(args[i]);
                }
                Write(">");
            }
            else
            {
                WriteNonGenericClrType(s);
            }
        }

        /// <summary>
        /// Writes a Clr type.
        /// </summary>
        protected internal void WriteClrType(string type)
        {
            var p = type.IndexOf('<');
            if (p >= 0)
            {
                WriteNonGenericClrType(type.Substring(0, p));
                Write("<");
                if (type[type.Length - 1] != '>')
                    throw new Exception("Panic: invalid generic type.");
                var args = type.Substring(p + 1, type.Length - p - 2).Split(',');
                for (var i = 0; i < args.Length; i++)
                {
                    if (i > 0) Write(", ");
                    WriteClrType(args[i]);
                }
                Write(">");
            }
            else
            {
                WriteNonGenericClrType(type);
            }
        }

        private void WriteNonGenericClrType(string s)
        {
            // safe
            if (s.Contains('{'))
                throw new Exception("Panic: cannot write a ModelType");

            // takes care eg of "System.Int32" vs. "int"
            if (TypesMap.TryGetValue(s, out var typeName))
            {
                Write(typeName);
                return;
            }

            // if full type name matches a using clause, strip
            // so if we want Umbraco.Core.Models.IPublishedContent
            // and using Umbraco.Core.Models, then we just need IPublishedContent
            // also works for the models namespace
            typeName = s;
            string typeUsing = null;
            var p = typeName.LastIndexOf('.');
            if (p > 0)
            {
                var x = typeName.Substring(0, p);
                if (CodeModel.Using.Contains(x) || x == CodeModel.ModelsNamespace)
                {
                    typeName = typeName.Substring(p + 1);
                    typeUsing = x;
                }
            }

            // nested types *after* using
            typeName = typeName.Replace("+", ".");

            // symbol to test is the first part of the name
            // so if type name is Foo.Bar.Nil we want to ensure that Foo is not ambiguous
            p = typeName.IndexOf('.');
            var symbol = p > 0 ? typeName.Substring(0, p) : typeName;

            // what we should find - WITHOUT any generic <T> thing - just the type
            // no 'using' = the exact symbol
            // a 'using' = using.symbol
            var match = typeUsing == null ? symbol : (typeUsing + "." + symbol);

            // if not ambiguous, be happy
            if (!CodeModel.IsAmbiguousSymbol(symbol, match))
            {
                Write(typeName);
                return;
            }

            // symbol is ambiguous
            // if no 'using', must prepend global::
            if (typeUsing == null)
            {
                Write("global::");
                Write(s.Replace("+", "."));
                return;
            }

            // could fullname be non-ambiguous?
            // note: all-or-nothing, not trying to segment the using clause
            typeName = s.Replace("+", ".");
            p = typeName.IndexOf('.');
            symbol = typeName.Substring(0, p);
            match = symbol;

            // still ambiguous, must prepend global::
            if (CodeModel.IsAmbiguousSymbol(symbol, match))
                Write("global::");

            Write(typeName);
        }

        private static readonly IDictionary<string, string> TypesMap = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            { "System.Int16", "short" },
            { "System.Int32", "int" },
            { "System.Int64", "long" },
            { "System.String", "string" },
            { "System.Object", "object" },
            { "System.Boolean", "bool" },
            { "System.Void", "void" },
            { "System.Char", "char" },
            { "System.Byte", "byte" },
            { "System.UInt16", "ushort" },
            { "System.UInt32", "uint" },
            { "System.UInt64", "ulong" },
            { "System.SByte", "sbyte" },
            { "System.Single", "float" },
            { "System.Double", "double" },
            { "System.Decimal", "decimal" }
        };

        #endregion
    }
}