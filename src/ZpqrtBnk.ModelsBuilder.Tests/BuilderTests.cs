using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using NUnit.Framework;
using Umbraco.Core.Composing;
using Umbraco.Core.Configuration.UmbracoSettings;
using Umbraco.Core.Models;
using Umbraco.Core.Models.PublishedContent;
using ZpqrtBnk.ModelsBuilder.Api;
using ZpqrtBnk.ModelsBuilder.Building;
using ZpqrtBnk.ModelsBuilder.Configuration;

namespace ZpqrtBnk.ModelsBuilder.Tests
{
    [TestFixture]
    public class BuilderTests
    {
        private Config _config;

        [SetUp]
        public void Setup()
        {
            _config = new Config();

            Current.Reset();
            Current.UnlockConfigs();
            Current.Configs.Add(() => _config);
            Current.Configs.Add<IUmbracoSettingsSection>(() => new UmbracoSettingsSection());
        }

        private static string ExpectedHeader
            => @"//------------------------------------------------------------------------------
// <auto-generated>
//   This code was generated by a tool.
//
//    ZpqrtBnk.ModelsBuilder v" + ApiVersion.Current.Version + @"
//
//   Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Web;
using Umbraco.Core.Models;
using Umbraco.Core.Models.PublishedContent;
using Umbraco.Web;
using ZpqrtBnk.ModelsBuilder;
using ZpqrtBnk.ModelsBuilder.Umbraco;
using System.CodeDom.Compiler;";

        private static void AddReference<T>(List<PortableExecutableReference> references)
        {
            references.Add(MetadataReference.CreateFromFile(typeof(T).Assembly.Location));
        }

        private static List<PortableExecutableReference> CreateDefaultReferences()
        {
            var references = new List<PortableExecutableReference>();
            AddReference<object>(references); // System
            AddReference<ContentTypeModelInfo>(references); // ZpqrtBnk.ModelsBuilder
            return references;
        }

        private static void AssertCanCompile(IDictionary<string, string> sources, List<PortableExecutableReference> refs)
        {
            // add refs for compilation
            AddReference<global::Umbraco.Core.ICompletable>(refs); // Umbraco.Core
            AddReference<global::Umbraco.Web.IHttpContextAccessor>(refs); // Umbraco.Web
            AddReference<IQueryProvider>(refs); // System.Linq
            AddReference<global::System.Web.HtmlString>(refs); // System.Web
            AddReference<global::System.CodeDom.Compiler.GeneratedCodeAttribute>(refs); // System.CodeDom

            // assert generated code can compile
            var compiler = new Compiler { References = refs };
            var compilation = compiler.GetCompilation("assembly", sources);
            var diagnostics = compilation.GetDiagnostics()
                .Where(x => x.Severity != DiagnosticSeverity.Hidden)
                .ToArray();
            foreach (var diagnostic in diagnostics)
                Console.WriteLine(diagnostic);
            Assert.AreEqual(0, diagnostics.Length);
        }

        [Test]
        public void ConfigureModelsNamespaceAttribute()
        {
            var sources = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
[assembly:ModelsBuilderConfigure(Namespace=""Foo.Bar.Nil"")]
"}
            };

            var transform = new CodeParser().Parse(sources, CreateDefaultReferences());

            Assert.IsTrue(transform.HasModelsNamespace);
            Assert.AreEqual("Foo.Bar.Nil", transform.ModelsNamespace);
        }

        [Test]
        public void CustomizeUsing()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };

            var types = new List<ContentTypeModel> { type1 };

            var code = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
"}
            };

            var transform = new CodeParser().Parse(code, CreateDefaultReferences());

            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            var count = model.Using.Count;

            model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            model.Using.Add("Foo.Bar.Nil");

            Assert.AreEqual(count + 1, model.Using.Count);
            Assert.IsTrue(model.Using.Contains("Foo.Bar.Nil"));
        }

        [Test]
        public void IgnoreContentType()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };

            var types = new List<ContentTypeModel> { type1 };

            var sources = new Dictionary<string, string>
            { };

            var transform = new CodeParser().Parse(sources, CreateDefaultReferences());
            transform.IgnoreContentType("type1");
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);

            Assert.IsTrue(transform.IsIgnored("type1"));

            Assert.AreEqual(0, types.Count);
        }

        [Test]
        public void ReferencedAssemblies()
        {
            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };

            var types = new List<ContentTypeModel> { type1 };

            var code1 = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
public partial class Type1
{}
"}
            };

            Assert.IsFalse(new CodeParser().Parse(code1).HasContentBase("Type1"));

            var code2 = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
public partial class Type1 : IHasXmlNode
{}
"}
            };

            // assumes base is IHasXmlNode (cannot be verified...)
            Assert.IsTrue(new CodeParser().Parse(code2).HasContentBase("Type1"));

            var code3 = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
using System.Xml;
public partial class Type1 : IHasXmlNode
{}
"}
            };

            // figures out that IHasXmlNode is an interface, not base
            // because of using + reference
            var asms = new[] {typeof(global::System.Xml.IHasXmlNode).Assembly}.Select(x => MetadataReference.CreateFromFile(x.Location));
            Assert.IsFalse(new CodeParser().Parse(code3, asms).HasContentBase("Type1"));
        }

        [Test]
        public void IgnoreContentTypeWildcard()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };

            var type2 = new ContentTypeModel
            {
                Id = 2,
                Alias = "type2",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };

            var type3 = new ContentTypeModel
            {
                Id = 3,
                Alias = "ttype3",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };

            var types = new List<ContentTypeModel> { type1, type2, type3 };

            var sources = new Dictionary<string, string>
            { };

            var transform = new CodeParser().Parse(sources, CreateDefaultReferences());
            var model = new IgnoreContentTypeWildcardCodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);

            Assert.IsTrue(transform.IsIgnored("type1"));
            Assert.IsTrue(transform.IsIgnored("type2"));
            Assert.IsFalse(transform.IsIgnored("ttype3"));

            Assert.AreEqual(1, types.Count);
            Assert.AreEqual("ttype3", types[0].Alias);
        }

        private class IgnoreContentTypeWildcardCodeModel : CodeModel
        {
            public override void Apply(Config config, ContentModelTransform transform, string modelsNamespace)
            {
                foreach (var contentTypeModel in ContentTypeModels)
                {
                    if (contentTypeModel.Alias.StartsWith("type"))
                        transform.IgnoreContentType(contentTypeModel.Alias);
                }

                base.Apply(config, transform, modelsNamespace);
            }
        }

        [Test]
        public void IgnoreParentContentType()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };

            var type2 = new ContentTypeModel
            {
                Id = 2,
                Alias = "type2",
                ParentId = 1,
                BaseType = type1,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };

            var types = new List<ContentTypeModel> { type1, type2 };

            var code = new Dictionary<string, string>
            { };

            var refs = new[]
            {
                MetadataReference.CreateFromFile(typeof (string).Assembly.Location),
                MetadataReference.CreateFromFile(typeof (ReferencedAssemblies).Assembly.Location)
            };

            var transform = new CodeParser().Parse(code, refs);
            transform.IgnoreContentType("type1");
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);

            Assert.IsTrue(transform.IsIgnored("type1"));
            Assert.IsFalse(transform.IsIgnored("type2"));

            Assert.AreEqual(0, types.Count);
        }

        [Test]
        public void IgnoreMixinContentType()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };

            var type2 = new ContentTypeModel
            {
                Id = 2,
                Alias = "type2",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type2.MixinTypes.Add(type1);

            var types = new List<ContentTypeModel> { type1, type2 };

            var code = new Dictionary<string, string>
            { };

            var refs = new[]
            {
                MetadataReference.CreateFromFile(typeof (string).Assembly.Location),
                MetadataReference.CreateFromFile(typeof (ReferencedAssemblies).Assembly.Location)
            };

            var transform = new CodeParser().Parse(code, refs);
            transform.IgnoreContentType("type1");
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);

            Assert.IsTrue(transform.IsIgnored("type1"));
            Assert.IsFalse(transform.IsIgnored("type2"));

            Assert.AreEqual(1, types.Count);
            Assert.AreEqual("type2", types[0].Alias);

            Assert.AreEqual(0, types[0].DeclaringInterfaces.Count);
        }

        [Test]
        public void RenameContentTypeWithTransform()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };

            var type2 = new ContentTypeModel
            {
                Id = 2,
                Alias = "type2",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };

            var types = new List<ContentTypeModel> { type1, type2 };

            var code = new Dictionary<string, string>
            { };

            var refs = new[]
            {
                MetadataReference.CreateFromFile(typeof (string).Assembly.Location),
                MetadataReference.CreateFromFile(typeof (ReferencedAssemblies).Assembly.Location)
            };

            var transform = new CodeParser().Parse(code, refs);
            transform.RenameContentType("type1", "Renamed1", false);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);

            Assert.IsFalse(transform.IsIgnored("type1"));
            Assert.IsFalse(transform.IsIgnored("type2"));
            Assert.IsTrue(transform.IsContentRenamed("type1"));
            Assert.IsFalse(transform.IsContentRenamed("type2"));
            Assert.AreEqual("Renamed1", transform.ContentClrName("type1"));
            Assert.IsNull(transform.ContentClrName("type2"));

            Assert.AreEqual(2, types.Count);
            Assert.AreEqual("Renamed1", types[0].ClrName);
            Assert.AreEqual("Type2", types[1].ClrName);
        }

        [Test]
        public void RenameContentTypeWithAttribute()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };

            var type2 = new ContentTypeModel
            {
                Id = 2,
                Alias = "type2",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };

            var types = new List<ContentTypeModel> { type1, type2 };

            var code = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
namespace Models
{
    [ImplementContentType(""type1"")]
    public partial class Renamed1
    {}
}
"}
            };

            var refs = new[]
            {
                MetadataReference.CreateFromFile(typeof (string).Assembly.Location),
                MetadataReference.CreateFromFile(typeof (ReferencedAssemblies).Assembly.Location)
            };

            var transform = new CodeParser().Parse(code, refs);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);

            Assert.IsFalse(transform.IsIgnored("type1"));
            Assert.IsFalse(transform.IsIgnored("type2"));
            Assert.IsTrue(transform.IsContentRenamed("type1"));
            Assert.IsFalse(transform.IsContentRenamed("type2"));
            Assert.AreEqual("Renamed1", transform.ContentClrName("type1"));
            Assert.IsNull(transform.ContentClrName("type2"));

            Assert.AreEqual(2, types.Count);
            Assert.AreEqual("Renamed1", types[0].ClrName);
            Assert.AreEqual("Type2", types[1].ClrName);
        }

        [Test]
        public void ContentTypeCustomBaseClass()
        {
            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            var type2 = new ContentTypeModel
            {
                Id = 2,
                Alias = "type2",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            var type3 = new ContentTypeModel
            {
                Id = 3,
                Alias = "type3",
                ParentId = 1,
                BaseType = type1,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            var types = new List<ContentTypeModel> { type1, type2, type3 };

            var code = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
using Dang;
namespace Dang
{
    public abstract class MyModelBase : PublishedContentModel
    {
        public MyModelBase(IPublishedContent content)
            : base(content)
        { }
    }

    public abstract class MyType1 : Type1
    {
        public MyType1(IPublishedContent content)
            : base(content)
        { }
    }

    public partial class Type1
    {}

    public partial class Type2 : MyModelBase
    {}

    public partial class Type3 : MyType1
    { }
}
"}
            };

            var transform = new CodeParser().Parse(code);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            var writer = new CodeWriter(model);

            Assert.AreEqual(3, types.Count);
            var btype1 = types[0];
            Assert.AreEqual("Type1", btype1.ClrName);
            var btype2 = types[1];
            Assert.AreEqual("Type2", btype2.ClrName);
            var btype3 = types[2];
            Assert.AreEqual("Type3", btype3.ClrName);

            Assert.IsFalse(btype1.HasBase);
            Assert.IsTrue(btype2.HasBase);
            Assert.IsTrue(btype3.HasBase);

            writer.WriteContentTypeModel(btype3);
            var gen = writer.Code;
            Console.WriteLine(gen);

            Assert.Greater(gen.IndexOf("public partial class Type3\n"), 0);
            Assert.Greater(0, gen.IndexOf("public partial class Type3 : "));
        }

        [Test]
        public void PropertyTypeIgnore()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var code = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
namespace Models
{
    [IgnorePropertyType(""prop1"")]
    public partial class Type1
    {
    }
}
"}
            };

            var refs = new[]
            {
                MetadataReference.CreateFromFile(typeof (string).Assembly.Location),
                MetadataReference.CreateFromFile(typeof (ReferencedAssemblies).Assembly.Location)
            };

            var transform = new CodeParser().Parse(code, refs);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);

            Assert.IsTrue(transform.IsPropertyIgnored("Type1", "prop1"));

            Assert.AreEqual(1, types.Count);
            Assert.AreEqual(0, types[0].Properties.Count);
        }

        [Test]
        public void PropertyTypeIgnoreWildcard()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop2",
                ContentType = type1,
                ModelClrType = typeof(string),
            });
            type1.Properties.Add(new PropertyModel
            {
                Alias = "pprop3",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var code = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
namespace Models
{
    [IgnorePropertyType(""prop*"")]
    public partial class Type1
    {
    }
}
"}
            };

            var refs = new[]
            {
                MetadataReference.CreateFromFile(typeof (string).Assembly.Location),
                MetadataReference.CreateFromFile(typeof (ReferencedAssemblies).Assembly.Location)
            };

            var transform = new CodeParser().Parse(code, refs);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);

            Assert.IsTrue(transform.IsPropertyIgnored("Type1", "prop1"));
            Assert.IsTrue(transform.IsPropertyIgnored("Type1", "prop2"));
            Assert.IsFalse(transform.IsPropertyIgnored("Type1", "pprop3"));

            Assert.AreEqual(1, types.Count);
            Assert.AreEqual(1, types[0].Properties.Count);
        }

        [Test]
        public void PropertyTypeIgnoreInherit()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var code = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
namespace Models
{
    [IgnorePropertyType(""prop1"")]
    public class Type2
    {
    }

    public partial class Type1 : Type2
    {
    }
}
"}
            };

            var refs = new[]
            {
                MetadataReference.CreateFromFile(typeof (string).Assembly.Location),
                MetadataReference.CreateFromFile(typeof (ReferencedAssemblies).Assembly.Location)
            };

            var transform = new CodeParser().Parse(code, refs);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);

            Assert.IsTrue(transform.IsPropertyIgnored("Type1", "prop1"));

            Assert.AreEqual(1, types.Count);
            Assert.AreEqual(0, types[0].Properties.Count);
        }

        [Test]
        public void PropertyTypeRenameOnClass()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var code = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
namespace Models
{
    [RenamePropertyType(""prop1"", ""Renamed1"")]
    [RenamePropertyType(""prop2"", ""Renamed2"")]
    public partial class Type1
    {
    }
}
"}
            };

            var refs = new[]
            {
                MetadataReference.CreateFromFile(typeof (string).Assembly.Location),
                MetadataReference.CreateFromFile(typeof (ReferencedAssemblies).Assembly.Location)
            };

            var transform = new CodeParser().Parse(code, refs);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);

            Assert.AreEqual("Renamed1", transform.PropertyClrName("Type1", "prop1"));
            Assert.AreEqual("Renamed2", transform.PropertyClrName("Type1", "prop2"));

            Assert.AreEqual(1, types.Count);
            Assert.IsTrue(types[0].Properties[0].ClrName == "Renamed1");
        }

        [Test]
        public void PropertyTypeRenameOnClassInherit()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var code = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
namespace Models
{
    [RenamePropertyType(""prop1"", ""Renamed1"")]
    [RenamePropertyType(""prop2"", ""Renamed2"")]
    public class Type2
    {
    }

    public partial class Type1 : Type2
    {
    }
}
"}
            };

            var refs = new[]
            {
                MetadataReference.CreateFromFile(typeof (string).Assembly.Location),
                MetadataReference.CreateFromFile(typeof (ReferencedAssemblies).Assembly.Location)
            };

            var transform = new CodeParser().Parse(code, refs);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);

            Assert.AreEqual("Renamed1", transform.PropertyClrName("Type1", "prop1"));
            Assert.AreEqual("Renamed2", transform.PropertyClrName("Type1", "prop2"));

            Assert.AreEqual(1, types.Count);
            Assert.IsTrue(types[0].Properties[0].ClrName == "Renamed1");
        }

        [Test]
        public void PropertyTypeRenameOnProperty()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var code = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
namespace Models
{
    public partial class Type1
    {
        [ImplementPropertyType(""prop1"")]
        public string Renamed1 { get { return """"; } }
    }
}
"}
            };

            var refs = new[]
            {
                MetadataReference.CreateFromFile(typeof (string).Assembly.Location),
                MetadataReference.CreateFromFile(typeof (ReferencedAssemblies).Assembly.Location)
            };

            var transform = new CodeParser().Parse(code, refs);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);

            Assert.IsTrue(transform.IsPropertyIgnored("Type1", "prop1"));

            Assert.AreEqual(1, types.Count);
            Assert.AreEqual(0, types[0].Properties.Count);
        }

        [Test]
        public void PropertyTypeRenameOnPropertyInherit()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var code = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
namespace Models
{
    public class Type2
    {
        [ImplementPropertyType(""prop1"")]
        public string Renamed1 { get { return """"; } }
    }

    public partial class Type1 : Type2
    {
    }
}
"}
            };

            var refs = new[]
            {
                MetadataReference.CreateFromFile(typeof (string).Assembly.Location),
                MetadataReference.CreateFromFile(typeof (ReferencedAssemblies).Assembly.Location)
            };

            var transform = new CodeParser().Parse(code, refs);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);

            Assert.IsTrue(transform.IsPropertyIgnored("Type1", "prop1"));

            Assert.AreEqual(1, types.Count);
            Assert.AreEqual(0, types[0].Properties.Count);
        }

        [Test]
        public void PropertyTypeImplementOnClass()
        {
            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });
            var types = new List<ContentTypeModel> { type1 };

            var code = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
using Dang;
namespace Dang
{
    public partial class Type1
    {
        [ImplementPropertyType(""prop1"")]
        public string Foo { get { return string.Empty; } }
    }
}
"}
            };

            var refs = new[]
            {
                MetadataReference.CreateFromFile(typeof (string).Assembly.Location),
                MetadataReference.CreateFromFile(typeof (ReferencedAssemblies).Assembly.Location)
            };

            var transform = new CodeParser().Parse(code, refs);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            var writer = new CodeWriter(model);

            Assert.AreEqual(1, types.Count);
            var btype1 = types[0];
            Assert.AreEqual("Type1", btype1.ClrName);

            writer.WriteContentTypeModel(btype1);
            var gen = writer.Code;
            Console.WriteLine(gen);

            Assert.Greater(0, gen.IndexOf("string Prop1"));
        }

        [Test]
        public void PropertyTypeImplementOnInterface()
        {
            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1a",
                ContentType = type1,
                ModelClrType = typeof(string),
            });
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1b",
                ContentType = type1,
                ModelClrType = typeof(string),
            });
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1c",
                ContentType = type1,
                ModelClrType = typeof(string),
            });
            var type2 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type2",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type2.Properties.Add(new PropertyModel
            {
                Alias = "prop2",
                ContentType = type2,
                ModelClrType = typeof(string),
            });
            var types = new List<ContentTypeModel> { type1, type2 };

            type2.MixinTypes.Add(type1);
            type1.IsMixin = true;

            var code = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
using Dang;
namespace Dang
{
    // both attributes are ignored on the interface - do it on the class
    //[RenamePropertyType(""prop1b"", ""Prop1x"")]
    //[IgnorePropertyType(""prop1c"")]
    public partial interface IType1
    {
        // attribute is not supported (ie ignored) here
        //[ImplementPropertyType(""prop1a"")]
        // have to do this (see notes in Type1)
        public string Foo { get; }
    }

    // both attributes on the class will be mirrored on the interface
    [RenamePropertyType(""prop1b"", ""Prop1x"")]
    [IgnorePropertyType(""prop1c"")]
    public partial class Type1
    {
        // and then,
        // - property will NOT be implemented in Type2, MUST be done manually
        // - property will NOT be mirrored on the interface, MUST be done manually
        [ImplementPropertyType(""prop1a"")]
        public string Foo { get { return string.Empty; } }
    }

    public partial class Type2
    {
        // have to do this (see notes in Type1)
        [ImplementPropertyType(""prop1a"")]
        public string Foo { get { return string.Empty; } }
    }
}
"}
            };

            var refs = new[]
            {
                MetadataReference.CreateFromFile(typeof (string).Assembly.Location),
                MetadataReference.CreateFromFile(typeof (ReferencedAssemblies).Assembly.Location)
            };

            var transform = new CodeParser().Parse(code, refs);
            var model = new CodeModel { ContentTypeModels = types, GeneratePropertyGetters = true }; // preserve
            model.Apply(_config, transform, null);
            var writer = new CodeWriter(model);

            Assert.AreEqual(2, types.Count);
            var btype1 = types[0];
            Assert.AreEqual("Type1", btype1.ClrName);
            var btype2 = types[1];
            Assert.AreEqual("Type2", btype2.ClrName);

            writer.WriteContentTypeModel(btype1);
            var gen = writer.Code;
            Console.WriteLine(gen);

            // contains
            Assert.Greater(gen.IndexOf("string Prop1x"), 0);
            // does not contain
            Assert.Greater(0, gen.IndexOf("string Prop1a"));
            Assert.Greater(0, gen.IndexOf("string Prop1b"));
            Assert.Greater(0, gen.IndexOf("string Prop1c"));

            writer.Reset();
            writer.WriteContentTypeModel(btype2);
            gen = writer.Code;
            Console.WriteLine(gen);

            // contains
            Assert.Greater(gen.IndexOf("string Prop2"), 0);
            Assert.Greater(gen.IndexOf("string Prop1x"), 0);
            // does not contain
            Assert.Greater(0, gen.IndexOf("string Prop1a"));
            Assert.Greater(0, gen.IndexOf("string Prop1b"));
            Assert.Greater(0, gen.IndexOf("string Prop1c"));
        }

        [Test]
        public void MixinPropertyStatic()
        {
            Current.Configs.Add(() => new Config());

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
                IsMixin = true,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1a",
                ContentType = type1,
                ModelClrType = typeof(string),
            });
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1b",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var type2 = new ContentTypeModel
            {
                Id = 2,
                Alias = "type2",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type2.MixinTypes.Add(type1);
            type2.Properties.Add(new PropertyModel
            {
                Alias = "prop2",
                ContentType = type2,
                ModelClrType = typeof(int),
            });

            var types = new List<ContentTypeModel> { type1, type2 };

            var sources = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;
using Test;
namespace Test
{
    public partial class Type1
    {
        public static int GetProp1a(IType1 that) => that.Value<int>(""prop1a"");
    }
}
"}
            };

            var expected = ExpectedHeader + @"

namespace Umbraco.Web.PublishedModels
{
    // Mixin Content Type with alias ""type1""
    public partial interface IType1 : IPublishedContent
    {
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        string Prop1a { get; }

        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        string Prop1b { get; }
    }

    /// <summary>Provides extension methods for the IType1 interface.</summary>
    public static partial class Type1Extensions
    {
        /// <summary>Gets the value of the ""prop1a"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop1a(this IType1 that, Fallback fallback = default, string defaultValue = default)
            => that.Value<string>(ModelInfos.ContentTypes.Type1.Properties.Prop1a.Alias, fallback: fallback, defaultValue: defaultValue);

        /// <summary>Gets the value of the ""prop1b"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop1b(this IType1 that, Fallback fallback = default, string defaultValue = default)
            => that.Value<string>(ModelInfos.ContentTypes.Type1.Properties.Prop1b.Alias, fallback: fallback, defaultValue: defaultValue);
    }

    /// <summary>Represents a ""type1"" content item.</summary>
    [PublishedModel(ModelInfos.ContentTypes.Type1.Alias)]
    public partial class Type1 : PublishedContentModel, IType1
    {
        public Type1(IPublishedContent content)
            : base(content)
        { }

        /// <summary>Gets the value of the ""prop1a"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type1.Properties.Prop1a.Alias)]
        public string Prop1a => this.Prop1a();

        /// <summary>Gets the value of the ""prop1b"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type1.Properties.Prop1b.Alias)]
        public string Prop1b => this.Prop1b();
    }
}
" + ExpectedHeader + @"

namespace Umbraco.Web.PublishedModels
{
    /// <summary>Provides extension methods for the Type2 class.</summary>
    public static partial class Type2Extensions
    {
        /// <summary>Gets the value of the ""prop2"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static int Prop2(this Type2 that, Fallback fallback = default, int defaultValue = default)
            => that.Value<int>(ModelInfos.ContentTypes.Type2.Properties.Prop2.Alias, fallback: fallback, defaultValue: defaultValue);
    }

    /// <summary>Represents a ""type2"" content item.</summary>
    [PublishedModel(ModelInfos.ContentTypes.Type2.Alias)]
    public partial class Type2 : PublishedContentModel, IType1
    {
        public Type2(IPublishedContent content)
            : base(content)
        { }

        /// <summary>Gets the value of the ""prop2"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type2.Properties.Prop2.Alias)]
        public int Prop2 => this.Prop2();

        /// <summary>Gets the value of the ""prop1a"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type1.Properties.Prop1a.Alias)]
        public string Prop1a => this.Prop1a();

        /// <summary>Gets the value of the ""prop1b"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type1.Properties.Prop1b.Alias)]
        public string Prop1b => this.Prop1b();
    }
}
";

            var transform = new CodeParser().Parse(sources);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            model.GeneratePropertyGetters = true; // preserve
            var writer = new CodeWriter(model);

            foreach (var typeModel in types)
                writer.WriteModelFile(typeModel);
            var generated = writer.Code;

            Console.WriteLine(generated);
            Assert.AreEqual(expected.ClearLf(), generated);
        }

        [Test]
        public void GenerateSimpleType()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var code = new Dictionary<string, string>
            { };

            var expected = ExpectedHeader + @"

namespace Umbraco.Web.PublishedModels
{
    /// <summary>Provides extension methods for the Type1 class.</summary>
    public static partial class Type1Extensions
    {
        /// <summary>Gets the value of the ""prop1"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop1(this Type1 that, Fallback fallback = default, string defaultValue = default)
            => that.Value<string>(ModelInfos.ContentTypes.Type1.Properties.Prop1.Alias, fallback: fallback, defaultValue: defaultValue);
    }

    /// <summary>Represents a ""type1"" content item.</summary>
    [PublishedModel(ModelInfos.ContentTypes.Type1.Alias)]
    public partial class Type1 : PublishedContentModel
    {
        public Type1(IPublishedContent content)
            : base(content)
        { }

        /// <summary>Gets the value of the ""prop1"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type1.Properties.Prop1.Alias)]
        public string Prop1 => this.Prop1();
    }
}
";

            var transform = new CodeParser().Parse(code);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            model.GeneratePropertyGetters = true; // preserve
            var writer = new CodeWriter(model);

            writer.WriteModelFile(types.First());
            var generated = writer.Code;

            Console.WriteLine(generated);
            Assert.AreEqual(expected.ClearLf(), generated);
        }

        [Test]
        public void GenerateSimpleTypeWithoutProperties()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var sources = new Dictionary<string, string>
            { };

            var expected = ExpectedHeader + @"

namespace Umbraco.Web.PublishedModels
{
    /// <summary>Provides extension methods for the Type1 class.</summary>
    public static partial class Type1Extensions
    {
        /// <summary>Gets the value of the ""prop1"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop1(this Type1 that, Fallback fallback = default, string defaultValue = default)
            => that.Value<string>(ModelInfos.ContentTypes.Type1.Properties.Prop1.Alias, fallback: fallback, defaultValue: defaultValue);
    }

    /// <summary>Represents a ""type1"" content item.</summary>
    [PublishedModel(ModelInfos.ContentTypes.Type1.Alias)]
    public partial class Type1 : PublishedContentModel
    {
        public Type1(IPublishedContent content)
            : base(content)
        { }
    }
}
";

            var transform = new CodeParser().Parse(sources);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            var writer = new CodeWriter(model);

            writer.WriteModelFile(types.First());
            var gen = writer.Code;

            Console.WriteLine(gen);
            Assert.AreEqual(expected.ClearLf(), gen);
        }

        [Test]
        public void GenerateSimpleTypeWithoutPropertiesWithFallbackFunc()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var sources = new Dictionary<string, string>
            { };

            var expected = ExpectedHeader + @"

namespace Umbraco.Web.PublishedModels
{
    /// <summary>Provides extension methods for the Type1 class.</summary>
    public static partial class Type1Extensions
    {
        /// <summary>Gets the value of the ""prop1"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop1(this Type1 that, Fallback fallback = default, string defaultValue = default)
            => that.Value<string>(ModelInfos.ContentTypes.Type1.Properties.Prop1.Alias, fallback: fallback, defaultValue: defaultValue);

        /// <summary>Gets the value of the ""prop1"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop1(this Type1 that, Func<Type1, string> fallback = default)
            => that.Value<Type1, string>(ModelInfos.ContentTypes.Type1.Properties.Prop1.Alias, fallback: fallback);
    }

    /// <summary>Represents a ""type1"" content item.</summary>
    [PublishedModel(ModelInfos.ContentTypes.Type1.Alias)]
    public partial class Type1 : PublishedContentModel
    {
        public Type1(IPublishedContent content)
            : base(content)
        { }
    }
}
";

            var transform = new CodeParser().Parse(sources);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            model.GenerateFallbackFuncExtensionMethods = true;
            var writer = new CodeWriter(model);

            writer.WriteModelFile(types.First());
            var generated = writer.Code;

            Console.WriteLine(generated);
            Assert.AreEqual(expected.ClearLf(), generated);
        }

        [Test]
        public void DontGeneratePropertyGetters()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var sources = new Dictionary<string, string>
            { };

            var expected = ExpectedHeader + @"

namespace Umbraco.Web.PublishedModels
{
    /// <summary>Provides extension methods for the Type1 class.</summary>
    public static partial class Type1Extensions
    {
        /// <summary>Gets the value of the ""prop1"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop1(this Type1 that, Fallback fallback = default, string defaultValue = default)
            => that.Value<string>(ModelInfos.ContentTypes.Type1.Properties.Prop1.Alias, fallback: fallback, defaultValue: defaultValue);
    }

    /// <summary>Represents a ""type1"" content item.</summary>
    [PublishedModel(ModelInfos.ContentTypes.Type1.Alias)]
    public partial class Type1 : PublishedContentModel
    {
        public Type1(IPublishedContent content)
            : base(content)
        { }
    }
}
";

            var transform = new CodeParser().Parse(sources, CreateDefaultReferences());
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            var writer = new CodeWriter(model);

            writer.WriteModelFile(types.First());
            var generated = writer.Code;

            Console.WriteLine(generated);
            Assert.AreEqual(expected.ClearLf(), generated);
        }

        [Test]
        public void GenerateSimpleType_AmbiguousIssue()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "foo",
                ContentType = type1,
                ModelClrType = typeof(IEnumerable<>).MakeGenericType(ModelType.For("foo")),
            });

            var type2 = new ContentTypeModel
            {
                Id = 2,
                Alias = "foo",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Element,
            };

            var types = new List<ContentTypeModel> { type1, type2 };

            var sources = new Dictionary<string, string>
            {
                { "code", @"
namespace Umbraco.Web.PublishedModels
{
    public partial class Foo
    { }
}
" }
            };

            var expected = ExpectedHeader + @"

namespace Umbraco.Web.PublishedModels
{
    /// <summary>Provides extension methods for the Type1 class.</summary>
    public static partial class Type1Extensions
    {
        /// <summary>Gets the value of the ""foo"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static IEnumerable<Foo> Foo(this Type1 that, Fallback fallback = default, IEnumerable<Foo> defaultValue = default)
            => that.Value<IEnumerable<Foo>>(ModelInfos.ContentTypes.Type1.Properties.Foo.Alias, fallback: fallback, defaultValue: defaultValue);
    }

    /// <summary>Represents a ""type1"" content item.</summary>
    [PublishedModel(ModelInfos.ContentTypes.Type1.Alias)]
    public partial class Type1 : PublishedContentModel
    {
        public Type1(IPublishedContent content)
            : base(content)
        { }

        /// <summary>Gets the value of the ""foo"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type1.Properties.Foo.Alias)]
        public IEnumerable<Foo> Foo => this.Foo();
    }
}
";

            var transform = new CodeParser().Parse(sources);

            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, "Umbraco.Web.PublishedModels");
            model.GeneratePropertyGetters = true; // preserve
            var writer = new CodeWriter(model);

            writer.WriteModelFile(types.Skip(1).First());
            var generated1 = writer.Code;
            Console.WriteLine(generated1);

            writer.Reset();
            writer.WriteModelFile(types.First());
            var generated = writer.Code;

            Console.WriteLine(generated);
            Assert.AreEqual(expected.ClearLf(), generated);
        }

        [Test]
        public void DetectPartialConstructor()
        {
            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var sources = new Dictionary<string, string>
            {
                { "assembly", @"
using ZpqrtBnk.ModelsBuilder;
using Umbraco.Core.Models;
using Umbraco.Core.Models.PublishedContent;

public partial class Type1
{
    public Type1(IPublishedContent content)
        : base(content)
    {
        // do our own stuff
    }
}
" }
            };

            var expected = ExpectedHeader + @"

namespace Umbraco.Web.PublishedModels
{
    /// <summary>Provides extension methods for the Type1 class.</summary>
    public static partial class Type1Extensions
    {
        /// <summary>Gets the value of the ""prop1"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop1(this Type1 that, Fallback fallback = default, string defaultValue = default)
            => that.Value<string>(ModelInfos.ContentTypes.Type1.Properties.Prop1.Alias, fallback: fallback, defaultValue: defaultValue);
    }

    /// <summary>Represents a ""type1"" content item.</summary>
    [PublishedModel(ModelInfos.ContentTypes.Type1.Alias)]
    public partial class Type1 : PublishedContentModel
    {
        /// <summary>Gets the value of the ""prop1"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type1.Properties.Prop1.Alias)]
        public string Prop1 => this.Prop1();
    }
}
";

            var refs = CreateDefaultReferences();
            AddReference<IPublishedContent>(refs);

            var transform = new CodeParser().Parse(sources, refs);

            Assert.IsTrue(transform.HasCtor("Type1"));

            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            model.GeneratePropertyGetters = true; // preserve
            var writer = new CodeWriter(model);

            writer.WriteModelFile(types.First());
            var generated = writer.Code;

            Console.WriteLine(generated);
            Assert.AreEqual(expected.ClearLf(), generated);
        }

        [Test]
        public void DetectPartialConstructorWithRename()
        {
            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var sources = new Dictionary<string, string>
            {
                { "assembly", @"
using ZpqrtBnk.ModelsBuilder;
using Umbraco.Core.Models;
using Umbraco.Core.Models.PublishedContent;

public partial class Type2
{
    public Type2(IPublishedContent content)
        : base(content)
    {
        // do our own stuff
    }
}
" }
            };

            var expected = ExpectedHeader + @"

namespace Umbraco.Web.PublishedModels
{
    /// <summary>Provides extension methods for the Type2 class.</summary>
    public static partial class Type2Extensions
    {
        /// <summary>Gets the value of the ""prop1"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop1(this Type2 that, Fallback fallback = default, string defaultValue = default)
            => that.Value<string>(ModelInfos.ContentTypes.Type2.Properties.Prop1.Alias, fallback: fallback, defaultValue: defaultValue);
    }

    // Content Type with alias ""type1""
    /// <summary>Represents a ""type1"" content item.</summary>
    [PublishedModel(ModelInfos.ContentTypes.Type2.Alias)]
    public partial class Type2 : PublishedContentModel
    {
        /// <summary>Gets the value of the ""prop1"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type2.Properties.Prop1.Alias)]
        public string Prop1 => this.Prop1();
    }
}
";

            var refs = CreateDefaultReferences();
            AddReference<IPublishedContent>(refs);

            var transform = new CodeParser().Parse(sources, refs);
            transform.RenameContentType("type1", "Type2", false);

            Assert.IsFalse(transform.HasCtor("Type1"));
            Assert.IsTrue(transform.HasCtor("Type2"));

            var model = new CodeModel { ContentTypeModels = types, GeneratePropertyGetters = true }; // preserve
            model.Apply(_config, transform, null);
            model.GeneratePropertyGetters = true; // preserve
            var writer = new CodeWriter(model);

            writer.WriteModelFile(types.First());
            var generated = writer.Code;

            Console.WriteLine(generated);
            Assert.AreEqual(expected.ClearLf(), generated);
        }

        [Test]
        public void GenerateMixinType()
        {
            // Umbraco returns nice, pascal-cased names

            Current.Configs.Add(() => new Config());

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
                IsMixin =  true,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var type2 = new ContentTypeModel
            {
                Id = 2,
                Alias = "type2",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type2.MixinTypes.Add(type1);
            type2.Properties.Add(new PropertyModel
            {
                Alias = "prop2",
                ContentType = type2,
                ModelClrType = typeof(int),
            });

            var types = new List<ContentTypeModel> { type1, type2 };

            var sources = new Dictionary<string, string>
            { };

            var transform = new CodeParser().Parse(sources);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            model.GeneratePropertyGetters = true; // preserve
            var writer = new CodeWriter(model);

            foreach (var typeModel in types)
                writer.WriteContentTypeModel(typeModel);
            var generated = writer.Code;

            Console.WriteLine(generated);

            //Assert.AreEqual(expected.ClearLf(), gen);
        }

        [Test]
        public void GenerateAmbiguous()
        {
            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
                IsMixin = true,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(IPublishedContent),
            });
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop2",
                ContentType = type1,
                ModelClrType = typeof(global::System.Text.StringBuilder),
            });
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop3",
                ContentType = type1,
                ModelClrType = typeof(global::Umbraco.Core.IO.FileSecurityException),
            });
            var types = new List<ContentTypeModel> { type1 };

            var code = new Dictionary<string, string>
            {
            };

            var transform = new CodeParser().Parse(code);
            // forces conflict with ZpqrtBnk.ModelsBuilder.Umbraco
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, "ZpqrtBnk.ModelsBuilder.Models");
            var writer = new CodeWriter(model);

            foreach (var typeModel in types)
                writer.WriteContentTypeModel(typeModel);
            var gen = writer.Code;

            Console.WriteLine(gen);

            Assert.IsTrue(gen.Contains(" IPublishedContent Prop1"));
            Assert.IsTrue(gen.Contains(" System.Text.StringBuilder Prop2"));
            Assert.IsTrue(gen.Contains(" global::Umbraco.Core.IO.FileSecurityException Prop3"));
        }

        [TestCase("int", typeof(int))]
        [TestCase("IEnumerable<int>", typeof(IEnumerable<int>))]
        [TestCase("ZpqrtBnk.ModelsBuilder.Tests.BuilderTestsClass1", typeof(BuilderTestsClass1))]
        [TestCase("ZpqrtBnk.ModelsBuilder.Tests.BuilderTests.Class1", typeof(Class1))]
        public void WriteClrType(string expected, Type input)
        {
            var model = new CodeModel();
            model.ModelsNamespaceForTests = "ModelsNamespace";
            model.Apply(_config, ContentModelTransform.Empty, null);
            var writer = new CodeWriter(model);

            writer.WriteClrType(input);
            Assert.AreEqual(expected, writer.Code);
        }

        [TestCase("int", typeof(int))]
        [TestCase("IEnumerable<int>", typeof(IEnumerable<int>))]
        [TestCase("BuilderTestsClass1", typeof(BuilderTestsClass1))]
        [TestCase("BuilderTests.Class1", typeof(Class1))]
        public void WriteClrTypeUsing(string expected, Type input)
        {
            var model = new CodeModel();
            model.ModelsNamespaceForTests = "ModelsNamespace";
            model.Apply(_config, ContentModelTransform.Empty, null);
            var writer = new CodeWriter(model);

            model.Using.Add("ZpqrtBnk.ModelsBuilder.Tests");

            writer.WriteClrType(input);
            Assert.AreEqual(expected, writer.Code);
        }

        [TestCase(true, true, "Borked", typeof(global::System.Text.ASCIIEncoding), "System.Text.ASCIIEncoding")]
        [TestCase(true, false, "Borked", typeof(global::System.Text.ASCIIEncoding), "ASCIIEncoding")]
        [TestCase(false, true, "Borked", typeof(global::System.Text.ASCIIEncoding), "System.Text.ASCIIEncoding")]
        [TestCase(false, false, "Borked", typeof(global::System.Text.ASCIIEncoding), "System.Text.ASCIIEncoding")]

        [TestCase(true, true, "ZpqrtBnk.ModelsBuilder.Tests", typeof(global::System.Text.ASCIIEncoding), "global::System.Text.ASCIIEncoding")]
        [TestCase(true, false, "ZpqrtBnk.ModelsBuilder.Tests", typeof(global::System.Text.ASCIIEncoding), "global::System.Text.ASCIIEncoding")]
        [TestCase(false, true, "ZpqrtBnk.ModelsBuilder.Tests", typeof(global::System.Text.ASCIIEncoding), "global::System.Text.ASCIIEncoding")]
        [TestCase(false, false, "ZpqrtBnk.ModelsBuilder.Tests", typeof(global::System.Text.ASCIIEncoding), "global::System.Text.ASCIIEncoding")]

        [TestCase(true, true, "Borked", typeof(StringBuilder), "StringBuilder")]
        [TestCase(true, false, "Borked", typeof(StringBuilder), "StringBuilder")]
        [TestCase(false, true, "Borked", typeof(StringBuilder), "System.Text.StringBuilder")] // magic? using = not ambiguous
        [TestCase(false, false, "Borked", typeof(StringBuilder), "System.Text.StringBuilder")]

        [TestCase(true, true, "ZpqrtBnk.ModelsBuilder.Tests", typeof(StringBuilder), "StringBuilder")]
        [TestCase(true, false, "ZpqrtBnk.ModelsBuilder.Tests", typeof(StringBuilder), "StringBuilder")]
        [TestCase(false, true, "ZpqrtBnk.ModelsBuilder.Tests", typeof(StringBuilder), "global::System.Text.StringBuilder")] // magic? in ns = ambiguous
        [TestCase(false, false, "ZpqrtBnk.ModelsBuilder.Tests", typeof(StringBuilder), "global::System.Text.StringBuilder")]
        public void WriteClrType_Ambiguous_Ns(bool usingSystem, bool usingZb, string ns, Type type, string expected)
        {
            var model = new CodeModel();
            model.ModelsNamespaceForTests = ns;
            model.Apply(_config, ContentModelTransform.Empty, null);
            var writer = new CodeWriter(model);

            if (usingSystem) model.Using.Add("System.Text");
            if (usingZb) model.Using.Add("ZpqrtBnk.ModelsBuilder.Tests");

            writer.WriteClrType(type);

            Assert.AreEqual(expected, writer.Code);
        }

        [Test]
        public void WriteClrType_AmbiguousWithNested()
        {
            var model = new CodeModel();
            model.ModelsNamespaceForTests = "SomeRandomNamespace";
            model.Apply(_config, ContentModelTransform.Empty, null);
            var writer = new CodeWriter(model);

            model.Using.Add("System.Text");
            model.Using.Add("ZpqrtBnk.ModelsBuilder.Tests");

            writer.WriteClrType(typeof(ASCIIEncoding.Nested));

            // full type name is needed but not global::
            Assert.AreEqual("ZpqrtBnk.ModelsBuilder.Tests.ASCIIEncoding.Nested", writer.Code);
        }

        [Test]
        public void VaryingProperties()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
                Variations = ContentVariation.Culture
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
                Variations = ContentVariation.Culture
            });
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop2",
                ContentType = type1,
                ModelClrType = typeof(string),
                Variations = ContentVariation.Culture
            });
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop3",
                ContentType = type1,
                ModelClrType = typeof(string),
                Variations = ContentVariation.Segment
            });
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop4",
                ContentType = type1,
                ModelClrType = typeof(string),
                Variations = ContentVariation.CultureAndSegment
            });
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop5",
                ContentType = type1,
                ModelClrType = typeof(string)
            });
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop6",
                ContentType = type1,
                ModelClrType = typeof(string),
                Variations = ContentVariation.Culture
            });

            var types = new List<ContentTypeModel> { type1 };

            var sources = new Dictionary<string, string>
            {
                {"ourFile1", @"
using System;
using ZpqrtBnk.ModelsBuilder;
namespace Umbraco.Web.PublishedModels
{
    public static partial class Type1Extensions
    {
        public static string Prop1(this Type1 that, string culture = null, string segment = null) => """";
    }

    [IgnorePropertyType(""prop6"")]
    public partial class Type1
    { }
}
"}
            };

            // expected:
            // - the prop1 extension method is detected and not generated
            // - the prop1 property is generated
            // - the prop6 property is entirely ignored
            // - all other properties are generated

            var expected = ExpectedHeader + @"

namespace Umbraco.Web.PublishedModels
{
    /// <summary>Provides extension methods for the Type1 class.</summary>
    public static partial class Type1Extensions
    {
        /// <summary>Gets the value of the ""prop2"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop2(this Type1 that, string culture = null, Fallback fallback = default, string defaultValue = default)
            => that.Value<string>(ModelInfos.ContentTypes.Type1.Properties.Prop2.Alias, culture: culture, fallback: fallback, defaultValue: defaultValue);

        /// <summary>Gets the value of the ""prop3"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop3(this Type1 that, string segment = null, Fallback fallback = default, string defaultValue = default)
            => that.Value<string>(ModelInfos.ContentTypes.Type1.Properties.Prop3.Alias, segment: segment, fallback: fallback, defaultValue: defaultValue);

        /// <summary>Gets the value of the ""prop4"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop4(this Type1 that, string culture = null, string segment = null, Fallback fallback = default, string defaultValue = default)
            => that.Value<string>(ModelInfos.ContentTypes.Type1.Properties.Prop4.Alias, culture: culture, segment: segment, fallback: fallback, defaultValue: defaultValue);

        /// <summary>Gets the value of the ""prop5"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop5(this Type1 that, Fallback fallback = default, string defaultValue = default)
            => that.Value<string>(ModelInfos.ContentTypes.Type1.Properties.Prop5.Alias, fallback: fallback, defaultValue: defaultValue);
    }

    /// <summary>Represents a ""type1"" content item.</summary>
    [PublishedModel(ModelInfos.ContentTypes.Type1.Alias)]
    public partial class Type1 : PublishedContentModel
    {
        public Type1(IPublishedContent content)
            : base(content)
        { }

        /// <summary>Gets the value of the ""prop1"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type1.Properties.Prop1.Alias)]
        public string Prop1 => this.Prop1();

        /// <summary>Gets the value of the ""prop2"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type1.Properties.Prop2.Alias)]
        public string Prop2 => this.Prop2();

        /// <summary>Gets the value of the ""prop3"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type1.Properties.Prop3.Alias)]
        public string Prop3 => this.Prop3();

        /// <summary>Gets the value of the ""prop4"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type1.Properties.Prop4.Alias)]
        public string Prop4 => this.Prop4();

        /// <summary>Gets the value of the ""prop5"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.Type1.Properties.Prop5.Alias)]
        public string Prop5 => this.Prop5();
    }
}
";

            var refs = CreateDefaultReferences();

            // get the writer
            var transform = new CodeParser().Parse(sources, refs);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            model.GeneratePropertyGetters = true; // preserve
            var writer = new CodeWriter(model);

            // write
            writer.WriteModelFile(types.First());

            // assert generated code
            var generated = sources["generated"] = writer.Code;
            Console.WriteLine(generated);
            Assert.AreEqual(expected.ClearLf(), generated);

            // add model infos for compilation
            writer.Reset();
            writer.WriteModelInfosFile(model);
            sources["modelInfos"] = writer.Code;
            Console.WriteLine(sources["modelInfos"]);

            // assert generated code can compile
            AssertCanCompile(sources, refs);
        }

        [Test]
        public void CustomizeContentTypeBaseClassName()
        {
            // Umbraco returns nice, pascal-cased names

            var types = new List<ContentTypeModel>();

            for (var i = 1; i < 5; i++)
            {
                types.Add(new ContentTypeModel
                {
                    Id = i,
                    Alias = "type" + i,
                    ParentId = 0,
                    BaseType = null,
                    ItemType = ContentTypeModel.ItemTypes.Content
                });
            }

            for (var i = 1; i < 5; i++)
            {
                types.Add(new ContentTypeModel
                {
                    Id = i + 4,
                    Alias = "type" + (i + 4),
                    ParentId = 0,
                    BaseType = null,
                    ItemType = ContentTypeModel.ItemTypes.Element
                });
            }

            var code = new Dictionary<string, string>
            {
                {"assembly", @"
using ZpqrtBnk.ModelsBuilder;

public class ContentModelBase1 {}
public class ElementModelBase1 {}
public class ContentModelBase2 {}
public class ElementModelBase2 {}
public class ContentModelBase3 {}
public class ElementModelBase3 {}
"}
            };

            var transform = new CodeParser().Parse(code, CreateDefaultReferences());
            var model = new CustomizeContentTypeBaseClassNameCodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            var writer = new CodeWriter(model);

            writer.WriteContentTypeModel(types[0]);
            var gen = writer.Code;

            Console.WriteLine(gen);
            Assert.IsTrue(gen.Contains("public partial class Type1 : ContentModelBase1"));

            writer.Reset();
            writer.WriteContentTypeModel(types[1]);
            gen = writer.Code;

            Console.WriteLine(gen);
            Assert.IsTrue(gen.Contains("public partial class Type2 : ContentModelBase1"));

            writer.Reset();
            writer.WriteContentTypeModel(types[2]);
            gen = writer.Code;

            Console.WriteLine(gen);
            Assert.IsTrue(gen.Contains("public partial class Type3 : ContentModelBase2"));

            writer.Reset();
            writer.WriteContentTypeModel(types[3]);
            gen = writer.Code;

            Console.WriteLine(gen);
            Assert.IsTrue(gen.Contains("public partial class Type4 : ContentModelBase3"));
            
            writer.Reset();
            writer.WriteContentTypeModel(types[4]);
            gen = writer.Code;

            Console.WriteLine(gen);
            Assert.IsTrue(gen.Contains("public partial class Type5 : ElementModelBase1"));
            
            writer.Reset();
            writer.WriteContentTypeModel(types[5]);
            gen = writer.Code;

            Console.WriteLine(gen);
            Assert.IsTrue(gen.Contains("public partial class Type6 : ElementModelBase1"));

            writer.Reset();
            writer.WriteContentTypeModel(types[6]);
            gen = writer.Code;

            Console.WriteLine(gen);
            Assert.IsTrue(gen.Contains("public partial class Type7 : ElementModelBase2"));

            writer.Reset();
            writer.WriteContentTypeModel(types[7]);
            gen = writer.Code;

            Console.WriteLine(gen);
            Assert.IsTrue(gen.Contains("public partial class Type8 : ElementModelBase3"));
        }

        private class CustomizeContentTypeBaseClassNameCodeModel : CodeModel
        {
            public override string GetBaseClrName(ContentTypeModel contentTypeModel)
            {

                // FIXME attribute returned a TYPE now we want a NAME?

                if (contentTypeModel.IsElement) {
                    if (contentTypeModel.Alias.EndsWith("7", StringComparison.OrdinalIgnoreCase))
                        return "ElementModelBase2";
                    if (contentTypeModel.Alias.Equals("type8", StringComparison.OrdinalIgnoreCase))
                        return "ElementModelBase3";
                    return "ElementModelBase1";
                }

                if (contentTypeModel.Alias.EndsWith("3", StringComparison.OrdinalIgnoreCase))
                    return "ContentModelBase2";
                if (contentTypeModel.Alias.Equals("type4", StringComparison.OrdinalIgnoreCase))
                    return "ContentModelBase3";
                return "ContentModelBase1";
            }
        }

        [Test]
        public void GenerateSimpleMeta()
        {
            // Umbraco returns nice, pascal-cased names

            var types = new List<ContentTypeModel>();
            
            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });
            types.Add(type1);

            var type2 = new ContentTypeModel
            {
                Id = 2,
                Alias = "type2",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type2.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type2,
                ModelClrType = typeof(string),
            });
            type2.Properties.Add(new PropertyModel
            {
                Alias = "prop2",
                ContentType = type2,
                ModelClrType = typeof(global::System.Web.IHtmlString),
            });
            type2.Properties.Add(new PropertyModel
            {
                Alias = "prop3",
                ContentType = type2,
                ModelClrType = typeof(string),
            });
            types.Add(type2);

            var type3 = new ContentTypeModel
            {
                Id = 3,
                Alias = "type3",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Media,
            };
            types.Add(type3);

            var sources = new Dictionary<string, string>
            { };

            var version = ApiVersion.Current.Version;
            var expected = @"//------------------------------------------------------------------------------
// <auto-generated>
//   This code was generated by a tool.
//
//    ZpqrtBnk.ModelsBuilder v" + version + @"
//
//   Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Web;
using Umbraco.Core.Models;
using Umbraco.Core.Models.PublishedContent;
using Umbraco.Web;
using ZpqrtBnk.ModelsBuilder;
using ZpqrtBnk.ModelsBuilder.Umbraco;
using System.Linq;
using System.CodeDom.Compiler;

namespace Umbraco.Web.PublishedModels
{
    /// <summary>Provides information about models.</summary>
    public static partial class ModelInfos
    {
        /// <summary>Gets ModelsBuilder's generator name.</summary>
        public const string Name = ""ZpqrtBnk.ModelsBuilder"";

        /// <summary>Gets the ModelsBuilder version that was used to generate the files.</summary>
        public const string VersionString = """ + version + @""";

        /// <summary>Provides information about content type models.</summary>
        public static class ContentTypes
        {
            /// <summary>Provides information about the Type1 content type.</summary>
            public static class Type1
            {
                public const PublishedItemType ItemType = PublishedItemType.Content;

                public const string Alias = ""type1"";

                public static IPublishedContentType GetContentType() => PublishedModelUtility.GetModelContentType(ItemType, Alias);

                /// <summary>Provides information about the properties of the Type1 content type.</summary>
                public static class Properties
                {
                    public static class Prop1
                    {
                        public const string Alias = ""prop1"";

                        public static IPublishedPropertyType GetPropertyType() => GetContentType().GetPropertyType(Alias);
                    }
                }
            }

            /// <summary>Provides information about the Type2 content type.</summary>
            public static class Type2
            {
                public const PublishedItemType ItemType = PublishedItemType.Content;

                public const string Alias = ""type2"";

                public static IPublishedContentType GetContentType() => PublishedModelUtility.GetModelContentType(ItemType, Alias);

                /// <summary>Provides information about the properties of the Type2 content type.</summary>
                public static class Properties
                {
                    public static class Prop1
                    {
                        public const string Alias = ""prop1"";

                        public static IPublishedPropertyType GetPropertyType() => GetContentType().GetPropertyType(Alias);
                    }

                    public static class Prop2
                    {
                        public const string Alias = ""prop2"";

                        public static IPublishedPropertyType GetPropertyType() => GetContentType().GetPropertyType(Alias);
                    }

                    public static class Prop3
                    {
                        public const string Alias = ""prop3"";

                        public static IPublishedPropertyType GetPropertyType() => GetContentType().GetPropertyType(Alias);
                    }
                }
            }

            /// <summary>Provides information about the Type3 content type.</summary>
            public static class Type3
            {
                public const PublishedItemType ItemType = PublishedItemType.Media;

                public const string Alias = ""type3"";

                public static IPublishedContentType GetContentType() => PublishedModelUtility.GetModelContentType(ItemType, Alias);

                /// <summary>Provides information about the properties of the Type3 content type.</summary>
                public static class Properties
                {
                }
            }
        }

        /// <summary>Gets the content type model infos.</summary>
        [GeneratedCodeAttribute(Name, VersionString)]
        public static IReadOnlyCollection<ContentTypeModelInfo> ContentTypeInfos => _contentTypeInfos;

        /// <summary>Gets the model infos for a content type.</summary>
        [GeneratedCodeAttribute(Name, VersionString)]
        public static ContentTypeModelInfo GetContentTypeInfos(string alias) => _contentTypeInfos.FirstOrDefault(x => x.Alias == alias);

        /// <summary>Gets the model infos for a content type.</summary>
        [GeneratedCodeAttribute(Name, VersionString)]
        public static ContentTypeModelInfo GetContentTypeInfos<TModel>() => _contentTypeInfos.FirstOrDefault(x => x.ClrType == typeof(TModel));

        /// <summary>Gets the model infos for a content type.</summary>
        [GeneratedCodeAttribute(Name, VersionString)]
        public static ContentTypeModelInfo GetContentTypeInfos(Type typeofModel) => _contentTypeInfos.FirstOrDefault(x => x.ClrType == typeofModel);

        [GeneratedCodeAttribute(Name, VersionString)]
        private static readonly ContentTypeModelInfo[] _contentTypeInfos = 
        {
            new ContentTypeModelInfo(""type1"", ""Type1"", typeof(Type1),
                new PropertyTypeModelInfo(""prop1"", ""Prop1"", typeof(string))),
            new ContentTypeModelInfo(""type2"", ""Type2"", typeof(Type2),
                new PropertyTypeModelInfo(""prop1"", ""Prop1"", typeof(string)),
                new PropertyTypeModelInfo(""prop2"", ""Prop2"", typeof(IHtmlString)),
                new PropertyTypeModelInfo(""prop3"", ""Prop3"", typeof(string))),
            new ContentTypeModelInfo(""type3"", ""Type3"", typeof(Type3))
        };
    }
}
";

            var transform = new CodeParser().Parse(sources);
            var model = new CodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            var writer = new CodeWriter(model);

            writer.WriteModelInfosFile(model);
            var generated = writer.Code;

            Console.WriteLine(generated);
            Assert.AreEqual(expected.ClearLf(), generated);

            sources["modelInfos"] = generated;
            for (var i = 0; i < types.Count; i++)
            {
                writer.Reset();
                writer.WriteModelFile(types[i]);
                sources["ourFile" + i] = writer.Code;
            }

            AssertCanCompile(sources, CreateDefaultReferences());
        }

        [Test]
        public void GenerateSimpleType_PrefixSuffix()
        {
            // Umbraco returns nice, pascal-cased names

            var type1 = new ContentTypeModel
            {
                Id = 1,
                Alias = "type1",
                ParentId = 0,
                BaseType = null,
                ItemType = ContentTypeModel.ItemTypes.Content,
            };
            type1.Properties.Add(new PropertyModel
            {
                Alias = "prop1",
                ContentType = type1,
                ModelClrType = typeof(string),
            });

            var types = new List<ContentTypeModel> { type1 };

            var sources = new Dictionary<string, string>
            { };

            var expected = ExpectedHeader + @"

namespace Umbraco.Web.PublishedModels
{
    /// <summary>Provides extension methods for the XxxType1Yyy class.</summary>
    public static partial class XxxType1YyyExtensions
    {
        /// <summary>Gets the value of the ""prop1"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        public static string Prop1(this XxxType1Yyy that, Fallback fallback = default, string defaultValue = default)
            => that.Value<string>(ModelInfos.ContentTypes.XxxType1Yyy.Properties.Prop1.Alias, fallback: fallback, defaultValue: defaultValue);
    }

    /// <summary>Represents a ""type1"" content item.</summary>
    [PublishedModel(ModelInfos.ContentTypes.XxxType1Yyy.Alias)]
    public partial class XxxType1Yyy : PublishedContentModel
    {
        public XxxType1Yyy(IPublishedContent content)
            : base(content)
        { }

        /// <summary>Gets the value of the ""prop1"" property.</summary>
        [GeneratedCodeAttribute(ModelInfos.Name, ModelInfos.VersionString)]
        [ImplementPropertyType(ModelInfos.ContentTypes.XxxType1Yyy.Properties.Prop1.Alias)]
        public string Prop1 => this.Prop1();
    }
}
";

            var transform = new CodeParser().Parse(sources, CreateDefaultReferences());
            var model = new PrefixSuffixCodeModel { ContentTypeModels = types };
            model.Apply(_config, transform, null);
            model.GeneratePropertyGetters = true; // preserve
            var writer = new CodeWriter(model);

            writer.WriteModelFile(types.First());
            var generated = writer.Code;

            Console.WriteLine(generated);
            Assert.AreEqual(expected.ClearLf(), generated);
        }

        public class PrefixSuffixCodeModel : CodeModel
        {
            public override string GetClrName(ContentTypeModel contentTypeModel)
            {
                return "Xxx" + base.GetClrName(contentTypeModel) + "Yyy";
            }
        }

        public class Class1 { }
    }

    // make it public to be ambiguous (see above)
    public class ASCIIEncoding
    {
        // can we handle nested types?
        public class Nested { }
    }

    class BuilderTestsClass1 {}

    public class System { }
}
