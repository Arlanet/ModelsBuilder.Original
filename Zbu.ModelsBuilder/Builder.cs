using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Roslyn.Compilers.CSharp;
using Umbraco.Core;
using Umbraco.Core.Models;
using Umbraco.Core.Models.PublishedContent;
using Umbraco.Core.Strings;

namespace Zbu.ModelsBuilder
{
    public class Builder
    {
        public List<GenType> GetTypes()
        {
            var contentTypeService = ApplicationContext.Current.Services.ContentTypeService;
            var contentTypes = contentTypeService.GetAllContentTypes();
            var mediaTypes = contentTypeService.GetAllMediaTypes();

            return GetTypes(contentTypes).ToList(); // fixme list?!
        }

        public void Generate(StringBuilder sb, IEnumerable<GenType> genTypes)
        {
            //var contentTypeService = ApplicationContext.Current.Services.ContentTypeService;
            //var contentTypes = contentTypeService.GetAllContentTypes();
            //var mediaTypes = contentTypeService.GetAllMediaTypes();

            //var genTypes = GetTypes(contentTypes);

            sb.Append("//------------------------------------------------------------------------------\n");
            sb.Append("// <auto-generated>\n");
            sb.Append("//   This code was generated by a tool.\n");
            sb.Append("//\n");
            sb.Append("//    Zbu.ModelsBuilder alpha\n");
            sb.Append("//\n");
            sb.Append("//   Changes to this file will be lost if the code is regenerated.\n");
            sb.Append("// </auto-generated>\n");
            sb.Append("//------------------------------------------------------------------------------\n");
            sb.Append("\n");

            foreach (var t in _typesUsing)
                sb.AppendFormat("using {0};\n", t);

            sb.Append("\n");
            sb.Append("namespace Zbu.ModelsBuilder.Tests.Models\n"); // FIXME should be configureable
            sb.Append("{\n");

            var more = false;
            foreach (var genType in genTypes)
            {
                if (more) sb.Append("\n");
                more = true;
                WriteContentType(sb, genType);
            }

            sb.Append("}\n");
        }

        #region Write

        void WriteContentType(StringBuilder sb, GenType type)
        {
            if (type.IsMixin)
            {
                // write the interface declaration
                sb.AppendFormat("\t// Mixin content Type {0} with alias \"{1}\"\n", type.Id, type.Alias);
                sb.AppendFormat("\tpublic partial interface I{0} : I{1}",
                    type.Name,
                    type.BaseType == null ? "PublishedContent" : type.BaseType.Name);

                // write the mixins
                foreach (var mixinType in type.DeclaringInterfaces)
                    sb.AppendFormat(", I{0}", mixinType.Name);

                sb.Append("\n\t{\n");

                // write the properties - only the local ones, we're an interface
                var more = false;
                foreach (var prop in type.Properties)
                {
                    if (more) sb.Append("\n");
                    more = true;
                    WriteInterfaceProperty(sb, prop);
                }

                sb.Append("\t}\n\n");
            }

            // write the class declaration
            sb.AppendFormat("\t// Content Type {0} with alias \"{1}\"\n", type.Id, type.Alias);
            sb.AppendFormat("\tpublic partial class {0} : {1}",
                type.Name,
                type.BaseType == null ? "PublishedContentModel" : type.BaseType.Name);

            // if it's a missing it implements its own interface
            if (type.IsMixin)
                sb.AppendFormat(", I{0}", type.Name);

            // write the mixins, if any, as interfaces
            // only if not a mixin because otherwise the interface already has them
            if (type.IsMixin == false)
                foreach (var mixinType in type.DeclaringInterfaces)
                    sb.AppendFormat(", I{0}", mixinType.Name);

            // begin class body
            sb.Append("\n\t{\n");

            // write the ctor
            sb.AppendFormat("\t\tpublic {0}(IPublishedContent content)\n\t\t\t: base(content)\n\t\t{{ }}\n",
                type.Name);

            // write the properties
            WriteContentTypeProperties(sb, type);

            // close the class declaration
            sb.Append("\t}\n");
        }

        void WriteContentTypeProperties(StringBuilder sb, GenType type)
        {
            // write the properties
            foreach (var prop in type.Properties)
                WriteProperty(sb, prop);

            // write the mixins properties
            foreach (var mixinType in type.ImplementingInterfaces)
                foreach (var prop in mixinType.Properties)
                    WriteProperty(sb, prop);
        }

        void WriteProperty(StringBuilder sb, GenProperty property)
        {
            sb.Append("\n");

            sb.Append("\t\tpublic ");
            WriteClrType(sb, property.ClrType);
            sb.AppendFormat(" {0}\n\t\t{{\n\t\t\tget {{ return this.GetPropertyValue",
                property.Name);
            if (property.ClrType != typeof(object))
            {
                sb.Append("<");
                WriteClrType(sb, property.ClrType);
                sb.Append(">");
            }
            sb.AppendFormat("(\"{0}\"); }}\n\t\t}}\n",
                property.Alias);
        }

        void WriteInterfaceProperty(StringBuilder sb, GenProperty property)
        {
            sb.Append("\t\t");
            WriteClrType(sb, property.ClrType);
            sb.AppendFormat(" {0} {{ get; }}\n",
                property.Name);
        }

        void WriteClrType(StringBuilder sb, Type type)
        {
            var s = type.ToString();

            if (type.IsGenericType)
            {
                var p = s.IndexOf('`');
                WriteNonGenericClrType(sb, s.Substring(0, p));
                sb.Append("<");
                var args = type.GetGenericArguments();
                for (var i = 0; i < args.Length; i++)
                {
                    if (i > 0) sb.Append(", ");
                    WriteClrType(sb, args[i]);
                }
                sb.Append(">");
            }
            else
            {
                WriteNonGenericClrType(sb, s);
            }
        }

        void WriteNonGenericClrType(StringBuilder sb, string s)
        {
            var ls = s.ToLowerInvariant();
            if (_typesMap.ContainsKey(ls))
            {
                s = _typesMap[ls];
            }
            else
            {
                var p = s.LastIndexOf('.');
                if (p > 0 && _typesUsing.Contains(s.Substring(0, p)))
                    s = s.Substring(p + 1);
            }

            sb.Append(s);
        }

        readonly IDictionary<string, string> _typesMap = new Dictionary<string, string>
        {
            { "system.int16", "short" },
            { "system.int32", "int" },
            { "system.int64", "long" },
            { "system.string", "string" },
            { "system.object", "object" },
            { "system.boolean", "bool" },
            { "system.void", "void" },
            { "system.char", "char" },
            { "system.byte", "byte" },
            { "system.uint16", "ushort" },
            { "system.uint32", "uint" },
            { "system.uint64", "ulong" },
            { "system.sbyte", "sbyte" },
            { "system.single", "float" },
            { "system.double", "double" },
            { "system.decimal", "decimal" }
        };

        readonly IList<string> _typesUsing = new List<string>
        {
            "System",
            "System.Collections.Generic",
            "System.Web",
            "Umbraco.Core.Models",
            "Umbraco.Core.Models.PublishedContent",
            "Umbraco.Web"
        };

        #endregion

        #region Prepare

        IEnumerable<GenType> GetTypes(IEnumerable<IContentType> types)
        {
            var gTypes = new List<GenType>();
            var aTypes = types.ToArray();
            foreach (var type in aTypes)
            {
                var gType = new GenType
                {
                    Id = type.Id,
                    Alias = type.Alias,
                    Name = type.Alias.ToCleanString(CleanStringType.PascalCase),
                    BaseTypeId = type.ParentId
                };

                gTypes.Add(gType);

                var publishedContentType = PublishedContentType.Get(PublishedItemType.Content, type.Alias);

                foreach (var property in type.PropertyTypes)
                {
                    var gProperty = new GenProperty
                    {
                        Alias = property.Alias,
                        Name = property.Alias.ToCleanString(CleanStringType.PascalCase)
                    };

                    var publishedPropertyType = publishedContentType.GetPropertyType(property.Alias);
                    gProperty.ClrType = publishedPropertyType.ClrType;

                    gType.Properties.Add(gProperty);
                }
            }

            // wire the base types
            foreach (var type in gTypes.Where(x => x.BaseTypeId > 0))
            {
                type.BaseType = gTypes.SingleOrDefault(x => x.Id == type.BaseTypeId);
                if (type.BaseType == null) throw new Exception();
            }

            // discover mixins
            foreach (var type in aTypes)
            {
                var gType0 = gTypes.SingleOrDefault(x => x.Id == type.Id);
                if (gType0 == null) throw new Exception();

                foreach (var cType in type.ContentTypeComposition)
                {
                    var gType = gTypes.SingleOrDefault(x => x.Id == cType.Id);
                    if (gType == null) throw new Exception();

                    if (cType.Id != type.ParentId)
                    {
                        // add to mixins
                        gType0.MixinTypes.Add(gType);

                        // mark as mixin - as well as parents
                        gType.IsMixin = true;
                        while ((gType = gType.BaseType) != null)
                            gType.IsMixin = true;
                    }
                }
            }

            // discover interfaces that need to be declared / implemented
            foreach (var gType in gTypes)
            {
                var parentTree = GetTypeTree(gType.BaseType);
                gType.DeclaringInterfaces.AddRange(gType.MixinTypes.Except(parentTree));

                var recursiveInterfaces = new List<GenType>();
                foreach (var i in gType.DeclaringInterfaces)
                    GetTypeTree(recursiveInterfaces, i);
                gType.ImplementingInterfaces.AddRange(recursiveInterfaces.Except(parentTree));
            }

            return gTypes;
        }

        List<GenType> GetTypeTree(GenType type)
        {
            var tree = new List<GenType>();
            if (type != null) GetTypeTree(tree, type);
            return tree;
        }

        void GetTypeTree(List<GenType> types, GenType type)
        {
            if (types.Contains(type) == false)
                types.Add(type);
            if (type.BaseType != null)
                GetTypeTree(types, type.BaseType);
            foreach (var mixin in type.MixinTypes)
                GetTypeTree(types, mixin);
        }

        public class GenType
        {
            public int Id;
            public string Alias;
            public string Name;
            public int BaseTypeId;
            public GenType BaseType;
            public readonly List<GenProperty> Properties = new List<GenProperty>();
            public readonly List<GenType> MixinTypes = new List<GenType>();
            public readonly List<GenType> DeclaringInterfaces = new List<GenType>();
            public readonly List<GenType> ImplementingInterfaces = new List<GenType>();
            public bool IsMixin;
        }

        public class GenProperty
        {
            public string Alias;
            public string Name;
            public Type ClrType;
        }

        #endregion    

        #region Parse

        public void Parse(string code, IList<GenType> genTypes)
        {
            var tree = SyntaxTree.ParseText(code);
            var writer = new CodeWalker();
            writer.Visit(tree.GetRoot(),
                alias => genTypes.RemoveAll(x => x.Alias.InvariantEquals(alias)),
                (contentName, propertyAlias) =>
                {
                    var type = genTypes.SingleOrDefault(x => x.Name == contentName);
                    if (type != null)
                        type.Properties.RemoveAll(x => x.Alias == propertyAlias);
                },
                (contentName, contentAlias) =>
                {
                    var type = genTypes.SingleOrDefault(x => x.Alias.InvariantEquals(contentAlias));
                    if (type != null)
                        type.Name = contentName;
                });
        }

        #endregion
    }
}
