using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Roslyn.Compilers.CSharp;

namespace Zbu.ModelsBuilder
{
    public class Builder
    {
        public static readonly string Version = Assembly.GetExecutingAssembly().GetName().Version.ToString();

        public string Namespace { get; set; }
        public IList<string> Using { get { return _typesUsing; } } 

        public void Generate(StringBuilder sb, TypeModel typeModel)
        {
            // FIXME should report Umbraco Version

            sb.Append("//------------------------------------------------------------------------------\n");
            sb.Append("// <auto-generated>\n");
            sb.Append("//   This code was generated by a tool.\n");
            sb.Append("//\n");
            sb.AppendFormat("//    Zbu.ModelsBuilder v{0}\n", Version);
            sb.Append("//\n");
            sb.Append("//   Changes to this file will be lost if the code is regenerated.\n");
            sb.Append("// </auto-generated>\n");
            sb.Append("//------------------------------------------------------------------------------\n");
            sb.Append("\n");

            foreach (var t in _typesUsing)
                sb.AppendFormat("using {0};\n", t);

            sb.Append("\n");
            sb.AppendFormat("namespace {0}\n", Namespace);
            sb.Append("{\n");

            WriteContentType(sb, typeModel);

            sb.Append("}\n");
        }

        #region Write

        void WriteContentType(StringBuilder sb, TypeModel type)
        {
            if (type.IsMixin)
            {
                // write the interface declaration
                sb.AppendFormat("\t// Mixin content Type {0} with alias \"{1}\"\n", type.Id, type.Alias);
                sb.AppendFormat("\tpublic partial interface I{0} : I{1}",
                    type.Name,
                    type.BaseType == null ? "PublishedContent" : type.BaseType.Name);

                // write the mixins
                foreach (var mixinType in type.DeclaringInterfaces)
                    sb.AppendFormat(", I{0}", mixinType.Name);

                sb.Append("\n\t{\n");

                // write the properties - only the local ones, we're an interface
                var more = false;
                foreach (var prop in type.Properties)
                {
                    if (more) sb.Append("\n");
                    more = true;
                    WriteInterfaceProperty(sb, prop);
                }

                sb.Append("\t}\n\n");
            }

            // write the class declaration
            sb.AppendFormat("\t// Content Type {0} with alias \"{1}\"\n", type.Id, type.Alias);
            sb.AppendFormat("\tpublic partial class {0} : {1}",
                type.Name,
                type.BaseType == null ? "PublishedContentModel" : type.BaseType.Name);

            // if it's a missing it implements its own interface
            if (type.IsMixin)
                sb.AppendFormat(", I{0}", type.Name);

            // write the mixins, if any, as interfaces
            // only if not a mixin because otherwise the interface already has them
            if (type.IsMixin == false)
                foreach (var mixinType in type.DeclaringInterfaces)
                    sb.AppendFormat(", I{0}", mixinType.Name);

            // begin class body
            sb.Append("\n\t{\n");

            // write the ctor
            sb.AppendFormat("\t\tpublic {0}(IPublishedContent content)\n\t\t\t: base(content)\n\t\t{{ }}\n",
                type.Name);

            // write the properties
            WriteContentTypeProperties(sb, type);

            // close the class declaration
            sb.Append("\t}\n");
        }

        void WriteContentTypeProperties(StringBuilder sb, TypeModel type)
        {
            // write the properties
            foreach (var prop in type.Properties)
                WriteProperty(sb, prop);

            // write the mixins properties
            foreach (var mixinType in type.ImplementingInterfaces)
                foreach (var prop in mixinType.Properties)
                    WriteProperty(sb, prop);
        }

        void WriteProperty(StringBuilder sb, PropertyModel property)
        {
            sb.Append("\n");

            sb.Append("\t\tpublic ");
            WriteClrType(sb, property.ClrType);
            sb.AppendFormat(" {0}\n\t\t{{\n\t\t\tget {{ return this.GetPropertyValue",
                property.Name);
            if (property.ClrType != typeof(object))
            {
                sb.Append("<");
                WriteClrType(sb, property.ClrType);
                sb.Append(">");
            }
            sb.AppendFormat("(\"{0}\"); }}\n\t\t}}\n",
                property.Alias);
        }

        void WriteInterfaceProperty(StringBuilder sb, PropertyModel property)
        {
            sb.Append("\t\t");
            WriteClrType(sb, property.ClrType);
            sb.AppendFormat(" {0} {{ get; }}\n",
                property.Name);
        }

        void WriteClrType(StringBuilder sb, Type type)
        {
            var s = type.ToString();

            if (type.IsGenericType)
            {
                var p = s.IndexOf('`');
                WriteNonGenericClrType(sb, s.Substring(0, p));
                sb.Append("<");
                var args = type.GetGenericArguments();
                for (var i = 0; i < args.Length; i++)
                {
                    if (i > 0) sb.Append(", ");
                    WriteClrType(sb, args[i]);
                }
                sb.Append(">");
            }
            else
            {
                WriteNonGenericClrType(sb, s);
            }
        }

        void WriteNonGenericClrType(StringBuilder sb, string s)
        {
            var ls = s.ToLowerInvariant();
            if (_typesMap.ContainsKey(ls))
            {
                s = _typesMap[ls];
            }
            else
            {
                var p = s.LastIndexOf('.');
                if (p > 0 && _typesUsing.Contains(s.Substring(0, p)))
                    s = s.Substring(p + 1);
            }

            sb.Append(s);
        }

        readonly IDictionary<string, string> _typesMap = new Dictionary<string, string>
        {
            { "system.int16", "short" },
            { "system.int32", "int" },
            { "system.int64", "long" },
            { "system.string", "string" },
            { "system.object", "object" },
            { "system.boolean", "bool" },
            { "system.void", "void" },
            { "system.char", "char" },
            { "system.byte", "byte" },
            { "system.uint16", "ushort" },
            { "system.uint32", "uint" },
            { "system.uint64", "ulong" },
            { "system.sbyte", "sbyte" },
            { "system.single", "float" },
            { "system.double", "double" },
            { "system.decimal", "decimal" }
        };

        readonly IList<string> _typesUsing = new List<string>
        {
            "System",
            "System.Collections.Generic",
            "System.Web",
            "Umbraco.Core.Models",
            "Umbraco.Core.Models.PublishedContent",
            "Umbraco.Web"
        };

        #endregion

        #region Prepare

        public void Prepare(IList<TypeModel> typeModels)
        {
            // discover interfaces that need to be declared / implemented
            foreach (var typeModel in typeModels)
            {
                var parentTree = typeModel.BaseType == null
                    ? new List<TypeModel>()
                    : typeModel.BaseType.GetTypeTree();

                typeModel.DeclaringInterfaces.AddRange(typeModel.MixinTypes.Except(parentTree));

                var recursiveInterfaces = new List<TypeModel>();
                foreach (var i in typeModel.DeclaringInterfaces)
                    TypeModel.GetTypeTree(recursiveInterfaces, i);
                typeModel.ImplementingInterfaces.AddRange(recursiveInterfaces.Except(parentTree));
            }
        }

        #endregion

        #region Parse

        public void Parse(string code, IList<TypeModel> genTypes)
        {
            var tree = SyntaxTree.ParseText(code);
            var writer = new CodeWalker();
            writer.Visit(tree.GetRoot(),
                alias => genTypes.RemoveAll(x => x.Alias.InvariantEquals(alias)),
                (contentName, propertyAlias) =>
                {
                    var type = genTypes.SingleOrDefault(x => x.Name == contentName);
                    if (type != null)
                        type.Properties.RemoveAll(x => x.Alias == propertyAlias);
                },
                (contentName, contentAlias) =>
                {
                    var type = genTypes.SingleOrDefault(x => x.Alias.InvariantEquals(contentAlias));
                    if (type != null)
                        type.Name = contentName;
                });
        }

        #endregion
    }
}
